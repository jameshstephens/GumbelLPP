/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 0e6eca4f-5376-490e-bd44-9664dc5c078c

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.

-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 453ac437-6b88-457f-88ef-9b180f5fe600

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.

-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: e25e4ca2-a4b3-4e1c-ac96-e7ea34020350

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definition of the function h_N(x) used in the coupling.
-/
noncomputable def h (N : ‚Ñù) (x : ‚Ñù) : ‚Ñù :=
  - Real.log (N * (1 - Real.exp (-Real.exp (-x) / N))) - x

/-
Lemma 1: Convexity and bounds for h_N(x).
-/
theorem lemma_1 (N : ‚Ñù) (hN : 1 ‚â§ N) :
    ConvexOn ‚Ñù Set.univ (h N) ‚àß
    (‚àÄ x, 0 < h N x ‚àß h N x ‚â§ Real.exp (-x) / N) ‚àß
    (‚àÄ x, 0 < x ‚Üí Real.exp (-x) / (3 * N) ‚â§ h N x) := by
      unfold ConvexOn h;
      refine' ‚ü® _, _, _ ‚ü©;
      ¬∑ -- We'll use the fact that $h_N(x)$ is the composition of convex functions.
        have h_convex : ConvexOn ‚Ñù Set.univ (fun x => -Real.log (1 - Real.exp (-Real.exp (-x) / N))) := by
          apply_rules [ convexOn_of_deriv2_nonneg, convex_univ ];
          ¬∑ field_simp;
            exact continuousOn_of_forall_continuousAt fun x hx => ContinuousAt.neg <| ContinuousAt.log ( continuousAt_const.sub <| Real.continuous_exp.continuousAt.comp <| ContinuousAt.neg <| ContinuousAt.div_const ( Real.continuous_exp.continuousAt.comp <| ContinuousAt.neg continuousAt_id ) _ ) <| ne_of_gt <| sub_pos_of_lt <| Real.exp_lt_one_iff.mpr <| neg_lt_zero.mpr <| by positivity;
          ¬∑ field_simp;
            exact DifferentiableOn.neg ( DifferentiableOn.log ( DifferentiableOn.sub ( differentiableOn_const _ ) ( DifferentiableOn.exp ( DifferentiableOn.neg ( DifferentiableOn.div_const ( DifferentiableOn.exp ( differentiableOn_id.neg ) ) _ ) ) ) ) fun x hx => ne_of_gt ( sub_pos.mpr ( Real.exp_lt_one_iff.mpr ( neg_lt_zero.mpr ( by positivity ) ) ) ) );
          ¬∑ refine' DifferentiableOn.congr _ _;
            use fun x => ( Real.exp ( -Real.exp ( -x ) / N ) * Real.exp ( -x ) / N ) / ( 1 - Real.exp ( -Real.exp ( -x ) / N ) );
            ¬∑ refine' DifferentiableOn.div _ _ _ <;> norm_num [ DifferentiableOn.exp, DifferentiableOn.neg, DifferentiableOn.mul, DifferentiableOn.div, differentiableOn_id, differentiableOn_const ];
              ¬∑ fun_prop (disch := norm_num);
              ¬∑ exact DifferentiableOn.exp ( DifferentiableOn.div_const ( DifferentiableOn.neg ( DifferentiableOn.exp ( differentiableOn_id.neg ) ) ) _ );
              ¬∑ exact fun x => sub_ne_zero_of_ne <| Ne.symm <| by norm_num ; positivity;
            ¬∑ intro x hx; norm_num [ Real.exp_ne_zero, Real.exp_neg, Real.differentiableAt_exp, ne_of_gt ( show 0 < 1 - Real.exp ( -Real.exp ( -x ) / N ) from sub_pos.mpr <| Real.exp_lt_one_iff.mpr <| by { exact div_neg_of_neg_of_pos ( neg_lt_zero.mpr <| Real.exp_pos _ ) <| by positivity } ) ] ; ring;
              convert congr_arg Neg.neg ( HasDerivAt.deriv ( HasDerivAt.log ( HasDerivAt.sub ( hasDerivAt_const _ _ ) ( HasDerivAt.exp ( HasDerivAt.neg ( HasDerivAt.mul ( HasDerivAt.inv ( Real.hasDerivAt_exp _ ) <| ne_of_gt <| Real.exp_pos _ ) <| hasDerivAt_const _ _ ) ) ) ) <| show ( 1 - Real.exp ( - ( ( Real.exp x ) ‚Åª¬π * N‚Åª¬π ) ) ) ‚â† 0 from sub_ne_zero.mpr <| Ne.symm <| by norm_num; positivity ) ) using 1 ; norm_num ; ring;
              norm_num [ sq, mul_assoc, Real.exp_ne_zero ];
          ¬∑ -- Let's calculate the first derivative of $h_N(x)$.
            have h_deriv : ‚àÄ x, deriv (fun x => -Real.log (1 - Real.exp (-Real.exp (-x) / N))) x = (Real.exp (-x) / N) * (Real.exp (-Real.exp (-x) / N)) / (1 - Real.exp (-Real.exp (-x) / N)) := by
              intro x; norm_num [ Real.exp_ne_zero, Real.exp_neg, Real.differentiableAt_exp, div_eq_mul_inv, mul_assoc, mul_comm, mul_left_comm, ne_of_gt ( show 0 < 1 - Real.exp ( -Real.exp ( -x ) / N ) from sub_pos.mpr <| by rw [ Real.exp_lt_one_iff ] ; exact div_neg_of_neg_of_pos ( neg_neg_of_pos <| Real.exp_pos _ ) <| by positivity ) ] ;
              norm_num [ Real.exp_ne_zero, Real.differentiableAt_exp, mul_comm, ne_of_gt ( show 0 < 1 - ( Real.exp ( N‚Åª¬π * ( Real.exp x ) ‚Åª¬π ) ) ‚Åª¬π from sub_pos.mpr <| inv_lt_one_of_one_lt‚ÇÄ <| by norm_num; positivity ) ] ; ring;
              norm_num [ sq, mul_assoc, Real.exp_ne_zero ];
            aesop;
            refine' ( HasDerivAt.deriv _ ) |> fun h => h.symm ‚ñ∏ _;
            convert HasDerivAt.div ( HasDerivAt.mul ( HasDerivAt.div_const ( HasDerivAt.exp ( hasDerivAt_neg x ) ) _ ) ( HasDerivAt.exp ( HasDerivAt.div_const ( HasDerivAt.neg ( HasDerivAt.exp ( hasDerivAt_neg x ) ) ) _ ) ) ) ( HasDerivAt.sub ( hasDerivAt_const _ _ ) ( HasDerivAt.exp ( HasDerivAt.div_const ( HasDerivAt.neg ( HasDerivAt.exp ( hasDerivAt_neg x ) ) ) _ ) ) ) _ using 1;
            ¬∑ exact ne_of_gt ( sub_pos_of_lt ( Real.exp_lt_one_iff.mpr ( by exact div_neg_of_neg_of_pos ( neg_neg_of_pos ( Real.exp_pos _ ) ) ( by positivity ) ) ) );
            ¬∑ rw [ le_div_iff‚ÇÄ ] <;> norm_num;
              ¬∑ ring_nf;
                nlinarith only [ show 0 ‚â§ Real.exp ( -x ) * N‚Åª¬π * Real.exp ( - ( Real.exp ( -x ) * N‚Åª¬π ) ) by positivity, show 0 ‚â§ Real.exp ( -x ) ^ 2 * N‚Åª¬π ^ 2 * Real.exp ( - ( Real.exp ( -x ) * N‚Åª¬π ) ) by positivity, Real.exp_pos ( -x ), Real.exp_pos ( - ( Real.exp ( -x ) * N‚Åª¬π ) ), Real.add_one_le_exp ( - ( Real.exp ( -x ) * N‚Åª¬π ) ), Real.add_one_le_exp ( -x ) ];
              ¬∑ exact pow_pos ( sub_pos_of_lt ( by rw [ Real.exp_lt_one_iff ] ; exact div_neg_of_neg_of_pos ( neg_neg_of_pos ( Real.exp_pos _ ) ) ( by positivity ) ) ) _;
        aesop;
        ¬∑ exact convex_univ;
        ¬∑ have := h_convex.2 ( Set.mem_univ x ) ( Set.mem_univ y ) a_1 a_2 a_3 ; aesop;
          rw [ Real.log_mul ( by positivity ) ( by exact ne_of_gt <| sub_pos.mpr <| Real.exp_lt_one_iff.mpr <| by exact div_neg_of_neg_of_pos ( neg_lt_zero.mpr <| Real.exp_pos _ ) <| by positivity ), Real.log_mul ( by positivity ) ( by exact ne_of_gt <| sub_pos.mpr <| Real.exp_lt_one_iff.mpr <| by exact div_neg_of_neg_of_pos ( neg_lt_zero.mpr <| Real.exp_pos _ ) <| by positivity ) ] at * ; aesop;
          rw [ Real.log_mul ( by positivity ) ( by exact ne_of_gt <| sub_pos.mpr <| Real.exp_lt_one_iff.mpr <| by exact div_neg_of_neg_of_pos ( neg_lt_zero.mpr <| Real.exp_pos _ ) <| by positivity ) ] ; nlinarith [ Real.log_le_sub_one_of_pos <| show 0 < N by positivity ] ;
      ¬∑ aesop;
        ¬∑ rw [ lt_neg, Real.log_lt_iff_lt_exp ];
          ¬∑ nlinarith [ Real.exp_pos ( -Real.exp ( -x ) / N ), Real.exp_neg ( -Real.exp ( -x ) / N ), mul_inv_cancel‚ÇÄ ( ne_of_gt ( Real.exp_pos ( -Real.exp ( -x ) / N ) ) ), Real.add_one_lt_exp ( show -Real.exp ( -x ) / N ‚â† 0 by exact div_ne_zero ( neg_ne_zero.mpr ( ne_of_gt ( Real.exp_pos _ ) ) ) ( by positivity ) ), Real.exp_pos ( -x ), Real.exp_neg x, mul_div_cancel‚ÇÄ ( -Real.exp ( -x ) ) ( by positivity : ( N : ‚Ñù ) ‚â† 0 ) ];
          ¬∑ exact mul_pos ( by positivity ) ( sub_pos_of_lt ( Real.exp_lt_one_iff.mpr ( by exact div_neg_of_neg_of_pos ( neg_lt_zero.mpr ( Real.exp_pos _ ) ) ( by positivity ) ) ) );
        ¬∑ rw [ neg_le ];
          rw [ ‚Üê Real.log_exp ( - ( Real.exp ( -x ) / N + x ) ) ];
          gcongr;
          ring_nf;
          rw [ sub_eq_add_neg, Real.exp_add ];
          nlinarith [ inv_pos.mpr ( zero_lt_one.trans_le hN ), mul_inv_cancel‚ÇÄ ( ne_of_gt ( zero_lt_one.trans_le hN ) ), Real.exp_pos ( -x ), Real.exp_pos ( - ( Real.exp ( -x ) * N‚Åª¬π ) ), Real.exp_neg ( Real.exp ( -x ) * N‚Åª¬π ), mul_inv_cancel‚ÇÄ ( ne_of_gt ( Real.exp_pos ( Real.exp ( -x ) * N‚Åª¬π ) ) ), Real.add_one_le_exp ( -x ), Real.add_one_le_exp ( - ( Real.exp ( -x ) * N‚Åª¬π ) ), Real.add_one_le_exp ( Real.exp ( -x ) * N‚Åª¬π ), Real.exp_neg ( -x ), mul_inv_cancel‚ÇÄ ( ne_of_gt ( Real.exp_pos ( -x ) ) ) ];
      ¬∑ -- Let $y = \frac{e^{-x}}{N}$. Since $x > 0$ and $N \geq 1$, we have $0 < y \leq 1$.
        intro x hx_pos
        set y := Real.exp (-x) / N
        have hy_pos : 0 < y := by
          positivity
        have hy_le_one : y ‚â§ 1 := by
          exact div_le_one_of_le‚ÇÄ ( le_trans ( Real.exp_le_one_iff.mpr ( neg_nonpos.mpr hx_pos.le ) ) hN ) ( by positivity );
        -- We want to prove $h_N(x) \geq \frac{y}{3}$, which is equivalent to $\frac{1 - e^{-y}}{y} \leq e^{-y/3}$.
        suffices h_ineq : (1 - Real.exp (-y)) / y ‚â§ Real.exp (-y / 3) by
          -- Taking the natural logarithm of both sides of the inequality $\frac{1 - e^{-y}}{y} \leq e^{-y/3}$, we get $-\ln\left(\frac{1 - e^{-y}}{y}\right) \geq \frac{y}{3}$.
          have h_log_ineq : -Real.log ((1 - Real.exp (-y)) / y) ‚â• y / 3 := by
            have := Real.log_le_log ( div_pos ( sub_pos.mpr <| Real.exp_lt_one_iff.mpr <| neg_lt_zero.mpr hy_pos ) hy_pos ) h_ineq ; norm_num at * ; linarith;
          rw [ Real.log_div ] at h_log_ineq <;> aesop;
          ¬∑ rw [ Real.log_mul ] at * <;> aesop;
            ¬∑ rw [ Real.log_div ( by positivity ) ( by positivity ), Real.log_exp ] at h_log_ineq ; ring_nf at * ; linarith;
            ¬∑ exact absurd a <| ne_of_gt <| sub_pos_of_lt <| Real.exp_lt_one_iff.mpr <| by ring_nf; norm_num; positivity;
          ¬∑ linarith;
        -- Consider $g(t) = 1 - t + \frac{t^2}{2} - \frac{t^3}{6} - e^{-t}$ for $t \geq 0$. Then $g'''(t) = -1 + e^{-t} \leq 0$, so $g(t) \leq 0$ for all $t \geq 0$.
        have h_g : ‚àÄ t : ‚Ñù, 0 ‚â§ t ‚Üí 1 - t + t^2 / 2 - t^3 / 6 ‚â§ Real.exp (-t) := by
          -- Let's choose any $t \geq 0$ and derive the inequality.
          intro t ht
          have h_deriv : ‚àÄ t : ‚Ñù, 0 ‚â§ t ‚Üí deriv (fun t => Real.exp t * (1 - t + t^2 / 2 - t^3 / 6)) t ‚â§ 0 := by
            intro t ht; norm_num [ Real.differentiableAt_exp, mul_comm, sub_add, add_assoc ] ; ring_nf; norm_num [ Real.exp_pos ] ;
            positivity;
          -- Since $g(t)$ is differentiable and its derivative is non-positive for $t \geq 0$, we can apply the Mean Value Theorem to $g(t)$ on the interval $[0, t]$.
          have h_mvt : ‚àÄ t : ‚Ñù, 0 < t ‚Üí ‚àÉ c ‚àà Set.Ioo 0 t, deriv (fun t => Real.exp t * (1 - t + t^2 / 2 - t^3 / 6)) c = (Real.exp t * (1 - t + t^2 / 2 - t^3 / 6) - Real.exp 0 * (1 - 0 + 0^2 / 2 - 0^3 / 6)) / (t - 0) := by
            intros t ht_pos;
            have := exists_deriv_eq_slope ( f := fun t => Real.exp t * ( 1 - t + t ^ 2 / 2 - t ^ 3 / 6 ) ) ht_pos;
            exact this ( Continuous.continuousOn <| by exact Continuous.mul ( Real.continuous_exp ) <| by exact Continuous.sub ( Continuous.add ( continuous_const.sub continuous_id' ) <| continuous_pow 2 |> Continuous.div_const <| 2 ) <| continuous_pow 3 |> Continuous.div_const <| 6 ) ( Differentiable.differentiableOn <| by exact Differentiable.mul ( Real.differentiable_exp ) <| by exact Differentiable.sub ( Differentiable.add ( differentiable_const _ |> Differentiable.sub <| differentiable_id' ) <| differentiable_pow 2 |> Differentiable.div_const <| 2 ) <| differentiable_pow 3 |> Differentiable.div_const <| 6 );
          cases lt_or_eq_of_le ht <;> aesop;
          obtain ‚ü® c, ‚ü® hc‚ÇÅ, hc‚ÇÇ ‚ü©, hc ‚ü© := h_mvt t h ; have := h_deriv c hc‚ÇÅ.le ; rw [ hc ] at this ; rw [ div_le_iff‚ÇÄ <| by positivity ] at this ; nlinarith [ Real.exp_pos t, Real.exp_neg t, mul_inv_cancel‚ÇÄ <| ne_of_gt <| Real.exp_pos t ];
        -- Hence $1 - e^{-t} \leq t - \frac{t^2}{2} + \frac{t^3}{6}$ so $\frac{1 - e^{-t}}{t} \leq 1 - \frac{t}{2} + \frac{t^2}{6} \leq 1 - \frac{t}{3}$ where the last inequality holds whenever $0 \leq t \leq 1$.
        have h_ineq : ‚àÄ t : ‚Ñù, 0 ‚â§ t ‚àß t ‚â§ 1 ‚Üí (1 - Real.exp (-t)) / t ‚â§ 1 - t / 3 := by
          intro t ht; rcases eq_or_lt_of_le ht.1 with ( rfl | ht‚ÇÅ ) <;> [ norm_num; rw [ div_le_iff‚ÇÄ ht‚ÇÅ ] ] ; nlinarith [ h_g t ht.1 ] ;
        exact le_trans ( h_ineq y ‚ü® hy_pos.le, hy_le_one ‚ü© ) ( by linarith [ Real.add_one_le_exp ( -y / 3 ) ] )

/-
Lemma 2: Perturbation bounds for LPP models.
-/
theorem lemma_2 {Pi : Type*} [Fintype Pi] [Nonempty Pi]
    (S_A S_B : Pi ‚Üí ‚Ñù) (pi_star : Pi)
    (h_pi_star : ‚àÄ p, S_A p ‚â§ S_A pi_star) :
    let M_A := S_A pi_star
    let M_AB := (Finset.univ.image (fun p => S_A p + S_B p)).max' (Finset.univ_nonempty.image _)
    let m_B := (Finset.univ.image S_B).min' (Finset.univ_nonempty.image _)
    let M_B := (Finset.univ.image S_B).max' (Finset.univ_nonempty.image _)
    m_B ‚â§ S_B pi_star ‚àß
    S_B pi_star ‚â§ M_AB - M_A ‚àß
    M_AB - M_A ‚â§ M_B := by
      aesop;
      ¬∑ exact Finset.min'_le _ _ ( Finset.mem_image_of_mem _ ( Finset.mem_univ _ ) );
      ¬∑ exact le_tsub_of_add_le_left ( by simpa [ add_comm ] using Finset.le_max' _ _ ( Finset.mem_image_of_mem ( fun p => S_A p + S_B p ) ( Finset.mem_univ pi_star ) ) );
      ¬∑ linarith [ h_pi_star a, Finset.le_max' ( Finset.image S_B Finset.univ ) ( S_B a ) ( Finset.mem_image_of_mem _ ( Finset.mem_univ a ) ) ]

/-
Definitions of GridPoint, Edge, GridPath, and IsValidPath.
-/
/-- A point in the grid $\mathbb{N}^2$. -/
def GridPoint := ‚Ñï √ó ‚Ñï

/-- An edge in the grid. -/
def Edge := GridPoint √ó GridPoint

/-- An edge is up-right if it goes from $(x,y)$ to $(x+1,y)$ or $(x,y+1)$. -/
def is_up_right (e : Edge) : Prop :=
  (e.2.1 = e.1.1 + 1 ‚àß e.2.2 = e.1.2) ‚à® (e.2.1 = e.1.1 ‚àß e.2.2 = e.1.2 + 1)

/-- A path is a list of edges. -/
def GridPath := List Edge

/-- A path is valid from start to end if it is a sequence of connected up-right edges. -/
inductive IsValidPath : GridPoint ‚Üí GridPoint ‚Üí GridPath ‚Üí Prop
  | nil (p : GridPoint) : IsValidPath p p []
  | cons (p q r : GridPoint) (l : GridPath) (h_edge : is_up_right (p, q)) (h_path : IsValidPath q r l) :
    IsValidPath p r ((p, q) :: l)

/-
The set of all valid paths from $(0,0)$ to $(m,n)$.
-/
noncomputable def paths (m n : ‚Ñï) : Finset GridPath :=
  let s := { l : GridPath | IsValidPath (0,0) (m,n) l }
  have h_finite : s.Finite := by
    -- Each valid path from $(0,0)$ to $(m,n)$ can be described by a sequence of moves, either right or down.
    have h_paths_finite : ‚àÄ p q : GridPoint, Set.Finite {l : GridPath | IsValidPath p q l ‚àß l.length ‚â§ m + n} := by
      intro p q;
      -- Each valid path from $(0,0)$ to $(m,n)$ can be described by a sequence of moves, either right or down. The number of such sequences is finite.
      have h_paths_finite : ‚àÄ p q : GridPoint, ‚àÄ k : ‚Ñï, Set.Finite { l : GridPath | IsValidPath p q l ‚àß l.length = k } := by
        intro p q k
        induction' k with k ih generalizing p q;
        ¬∑ refine Set.Finite.subset ( Set.finite_singleton [ ] ) ?_ ; aesop;
        ¬∑ have h_finite_edges : Set.Finite {e : Edge | is_up_right e ‚àß e.1 = p} := by
            exact Set.Finite.subset ( Set.toFinite { ( p, ( p.1 + 1, p.2 ) ), ( p, ( p.1, p.2 + 1 ) ) } ) fun e he => by cases he; aesop;
          refine' Set.Finite.subset ( h_finite_edges.biUnion fun e he => ih e.2 q |> Set.Finite.image fun l => ( e :: l ) ) _;
          intro l hl; rcases hl with ‚ü® hl‚ÇÅ, hl‚ÇÇ ‚ü© ; induction' l with e l ih <;> aesop;
          ¬∑ cases hl‚ÇÅ ; aesop;
            exact ‚ü® h_path, rfl ‚ü©;
          ¬∑ cases hl‚ÇÅ ; aesop;
          ¬∑ cases hl‚ÇÅ ; aesop;
      exact Set.Finite.subset ( Set.Finite.biUnion ( Set.finite_Iic ( m + n ) ) fun k hk => h_paths_finite p q k ) fun l hl => by aesop;
    refine h_paths_finite ( 0, 0 ) ( m, n ) |> Set.Finite.subset <| fun l hl => ?_;
    -- By definition of IsValidPath, each path from (0,0) to (m,n) consists of exactly m + n steps.
    have h_length : ‚àÄ p q : GridPoint, ‚àÄ l : GridPath, IsValidPath p q l ‚Üí l.length = q.1 + q.2 - p.1 - p.2 := by
      intros p q l hl; induction hl <;> aesop;
      rcases h_edge with ( ‚ü® h‚ÇÅ, h‚ÇÇ ‚ü© | ‚ü® h‚ÇÅ, h‚ÇÇ ‚ü© ) <;> simp_all +decide [ Nat.sub_sub ];
      ¬∑ have h_length : ‚àÄ p q : GridPoint, ‚àÄ l : GridPath, IsValidPath p q l ‚Üí p.1 ‚â§ q.1 ‚àß p.2 ‚â§ q.2 := by
          intros p q l hl; induction hl <;> aesop;
          ¬∑ cases h_edge <;> aesop;
            linarith;
          ¬∑ cases h_edge <;> aesop;
            linarith;
        grind;
      ¬∑ rw [ tsub_add_eq_add_tsub ];
        ¬∑ omega;
        ¬∑ have h_length : ‚àÄ p q : GridPoint, ‚àÄ l : GridPath, IsValidPath p q l ‚Üí p.1 ‚â§ q.1 ‚àß p.2 ‚â§ q.2 := by
            intros p q l hl; induction hl <;> aesop;
            ¬∑ cases h_edge <;> aesop ; linarith;
            ¬∑ cases h_edge <;> aesop ; linarith;
          linarith [ h_length _ _ _ h_path ];
    exact ‚ü® hl, h_length _ _ _ hl ‚ñ∏ by norm_num ‚ü©
  h_finite.toFinset

/-
The set of paths from (0,0) to (m,n) is nonempty.
-/
lemma paths_nonempty (m n : ‚Ñï) : (paths m n).Nonempty := by
  -- We'll use induction to prove that there is always a valid path from $(0,0)$ to $(m,n)$.
  induction' m with m ih generalizing n;
  ¬∑ use List.map ( fun i => ( ( 0, i ), ( 0, i + 1 ) ) ) ( List.range n );
    unfold paths; aesop;
    induction' n with n ih <;> simp_all +decide [ List.range_succ ];
    ¬∑ constructor;
    ¬∑ convert IsValidPath.cons _ _ _ _ _ _ using 1;
      rotate_left;
      exact ( 0, 1 );
      exact List.map ( fun i => ( ( 0, i + 1 ), 0, i + 2 ) ) ( List.range n );
      ¬∑ exact Or.inr ‚ü® rfl, rfl ‚ü©;
      ¬∑ have h_valid : ‚àÄ (p q : GridPoint) (l : GridPath), IsValidPath p q l ‚Üí IsValidPath (p.1, p.2 + 1) (q.1, q.2 + 1) (List.map (fun e => ((e.1.1, e.1.2 + 1), (e.2.1, e.2.2 + 1))) l) := by
          intros p q l hl; induction hl <;> aesop;
          ¬∑ constructor;
          ¬∑ apply_rules [ IsValidPath.cons ];
            cases h_edge <;> aesop;
            ¬∑ exact Or.inl ‚ü® rfl, rfl ‚ü©;
            ¬∑ exact Or.inr ‚ü® rfl, rfl ‚ü©;
        convert h_valid _ _ _ ih using 1;
        induction ( List.range n ) <;> aesop;
      ¬∑ exact Nat.recOn n ( by norm_num ) fun n ih => by simp_all +decide [ List.range_succ ] ;
  ¬∑ by_contra h_empty;
    obtain ‚ü®l, hl‚ü© : ‚àÉ l : GridPath, IsValidPath (0, 0) (m, n) l := by
      specialize ih n; unfold paths at ih; aesop;
    have h_path : ‚àÉ l' : GridPath, IsValidPath (m, n) (m + 1, n) l' := by
      exact ‚ü® [ ( ( m, n ), ( m + 1, n ) ) ], by exact IsValidPath.cons _ _ _ _ ( by exact Or.inl ‚ü® rfl, rfl ‚ü© ) ( by exact IsValidPath.nil _ ) ‚ü©;
    aesop;
    have h_path : ‚àÉ l' : GridPath, IsValidPath (0, 0) (m + 1, n) l' := by
      have h_path : ‚àÄ p q r : GridPoint, ‚àÄ l : GridPath, IsValidPath p q l ‚Üí ‚àÄ w : GridPath, IsValidPath q r w ‚Üí ‚àÉ l' : GridPath, IsValidPath p r l' := by
        intros p q r l hl w hw;
        induction hl <;> aesop;
        exact ‚ü® ( p_1, q_1 ) :: w_2, by exact IsValidPath.cons _ _ _ _ h_edge h_1 ‚ü©;
      exact h_path _ _ _ _ hl _ h;
    obtain ‚ü® l', hl' ‚ü© := h_path;
    replace h_empty := Finset.ext_iff.mp h_empty l'; aesop;
    exact h_empty <| by unfold paths; aesop;

/-
Definition of LPP value.
-/
/-- The Last Passage Percolation value for a given weight function. -/
noncomputable def LPP_value (m n : ‚Ñï) (weights : Edge ‚Üí ‚Ñù) : ‚Ñù :=
  ((paths m n).image (fun p => (p.map weights).sum)).max' (by simp [paths_nonempty])

/-
CDF of the N-approximate Gumbel distribution.
-/
noncomputable def f_approx_gumbel (N : ‚Ñù) (x : ‚Ñù) : ‚Ñù :=
  if x > -Real.log N then (1 - Real.exp (-x) / N) ^ N else 0

/-
CDF of the Gumbel distribution.
-/
noncomputable def gumbel_cdf (x : ‚Ñù) : ‚Ñù := Real.exp (-Real.exp (-x))

/-
The coupling identity: g(y) = f_N(h_N(y) + y).
-/
theorem coupling_identity (N : ‚Ñù) (hN : 1 ‚â§ N) (y : ‚Ñù) :
    gumbel_cdf y = f_approx_gumbel N (h N y + y) := by
      unfold gumbel_cdf f_approx_gumbel h;
      rw [ Real.exp_neg, inv_eq_iff_eq_inv ] ; norm_num;
      rw [ if_pos ];
      ¬∑ rw [ Real.exp_log ];
        ¬∑ rw [ mul_div_cancel_left‚ÇÄ _ ( by positivity ), sub_sub_cancel, ‚Üê Real.exp_mul ] ; ring;
          norm_num [ show N ‚â† 0 by linarith ];
          rw [ ‚Üê Real.exp_neg, neg_neg ];
        ¬∑ exact mul_pos ( by positivity ) ( sub_pos_of_lt ( Real.exp_lt_one_iff.mpr ( by ring_nf; norm_num; positivity ) ) );
      ¬∑ exact Real.log_lt_log ( mul_pos ( by positivity ) ( sub_pos.mpr ( by rw [ Real.exp_lt_one_iff ] ; exact div_neg_of_neg_of_pos ( neg_lt_zero.mpr ( Real.exp_pos _ ) ) ( by positivity ) ) ) ) ( mul_lt_of_lt_one_right ( by positivity ) ( sub_lt_self _ ( by positivity ) ) )

/-
Definitions of T_Gumbel, T_Approx, and L_Exp.
-/
open MeasureTheory ProbabilityTheory

noncomputable def T_Gumbel (m n : ‚Ñï) {Œ© : Type*} (Y : Edge ‚Üí Œ© ‚Üí ‚Ñù) : Œ© ‚Üí ‚Ñù :=
  fun œâ => LPP_value m n (fun e => Y e œâ)

noncomputable def T_Approx (m n : ‚Ñï) (N : ‚Ñù) {Œ© : Type*} (Y : Edge ‚Üí Œ© ‚Üí ‚Ñù) : Œ© ‚Üí ‚Ñù :=
  fun œâ => LPP_value m n (fun e => h N (Y e œâ) + Y e œâ)

noncomputable def L_Exp (m n : ‚Ñï) {Œ© : Type*} (E : Edge ‚Üí Œ© ‚Üí ‚Ñù) : Œ© ‚Üí ‚Ñù :=
  fun œâ => LPP_value m n (fun e => E e œâ)

/-
Constants C_g, sigma_g and the Tracy-Widom GUE distribution F_GUE.
-/
opaque C_g : ‚Ñù
opaque sigma_g : ‚Ñù
opaque F_GUE : ‚Ñù ‚Üí ‚Ñù

/-
Checking the signature of iIndepFun.
-/
#check iIndepFun

/-
Definition of a grid of i.i.d. Gumbel random variables.
-/
def IsGumbelGrid {Œ© : Type*} [MeasurableSpace Œ©] (Œº : Measure Œ©) (Y : Edge ‚Üí Œ© ‚Üí ‚Ñù) : Prop :=
  iIndepFun Y Œº ‚àß ‚àÄ e x, Œº {œâ | Y e œâ ‚â§ x} = ENNReal.ofReal (gumbel_cdf x)

/-
Checking for MeasurableSpace instance on Real and borel definition.
-/
#synth MeasurableSpace ‚Ñù
#check borel

/-
The scaled and centered LPP random variable.
-/
noncomputable def scaled_centered_LPP (n : ‚Ñï) (N : ‚Ñù) {Œ© : Type*} (Y : Edge ‚Üí Œ© ‚Üí ‚Ñù) : Œ© ‚Üí ‚Ñù :=
  fun œâ => (T_Approx n n N Y œâ - C_g * n) / (sigma_g * (n : ‚Ñù) ^ (1/3 : ‚Ñù))

/-
Definition of a grid of i.i.d. N-approximate Gumbel random variables.
-/
def IsApproxGumbelGrid {Œ© : Type*} [MeasurableSpace Œ©] (Œº : Measure Œ©) (N : ‚Ñù) (Y : Edge ‚Üí Œ© ‚Üí ‚Ñù) : Prop :=
  iIndepFun Y Œº ‚àß ‚àÄ e x, Œº {œâ | Y e œâ ‚â§ x} = ENNReal.ofReal (f_approx_gumbel N x)

/-
The sequence of probabilities in the main theorem.
-/
noncomputable def prob_seq (Œ± : ‚Ñù) (r : ‚Ñù)
  {Œ© : ‚Ñï ‚Üí Type*} [‚àÄ n, MeasurableSpace (Œ© n)] (Œº : ‚àÄ n, Measure (Œ© n)) (Y : ‚àÄ n, Edge ‚Üí Œ© n ‚Üí ‚Ñù) (n : ‚Ñï) : ‚Ñù :=
  ((Œº n) {œâ | scaled_centered_LPP n (Nat.floor ((n : ‚Ñù) ^ Œ±)) (Y n) œâ ‚â§ r}).toReal

/-
Upper bound on the difference between approximate and exact Gumbel LPP.
-/
theorem coupling_upper_bound (n : ‚Ñï) (N : ‚Ñù) (hN : 1 ‚â§ N) {Œ© : Type*} (Y : Edge ‚Üí Œ© ‚Üí ‚Ñù) (œâ : Œ©) :
    T_Approx n n N Y œâ - T_Gumbel n n Y œâ ‚â§ (1 / N) * L_Exp n n (fun e œâ => Real.exp (- (Y e œâ))) œâ := by
      norm_num [ T_Approx, T_Gumbel, L_Exp ];
      unfold LPP_value;
      rw [ Finset.max'_le_iff ];
      aesop;
      refine' add_le_add _ _;
      ¬∑ refine' le_trans _ ( mul_le_mul_of_nonneg_left ( Finset.le_max' _ _ <| Finset.mem_image_of_mem _ left ) <| by positivity );
        -- By Lemma 1, we know that $h_N(x) \leq e^{-x}/N$ for all $x$.
        have h_le : ‚àÄ x : ‚Ñù, h N x ‚â§ Real.exp (-x) / N := by
          exact fun x => lemma_1 N hN |>.2.1 x |>.2;
        simpa [ div_eq_inv_mul, List.sum_map_mul_left ] using List.sum_le_sum fun x hx => h_le ( Y x œâ );
      ¬∑ exact Finset.le_max' ( Finset.image ( fun p => ( List.map ( fun e => Y e œâ ) p ).sum ) ( paths n n ) ) _ ( Finset.mem_image_of_mem _ left )

/-
Lower bound on the difference between approximate and exact Gumbel LPP using Jensen's inequality.
-/
theorem coupling_lower_bound (n : ‚Ñï) (N : ‚Ñù) (hN : 1 ‚â§ N) {Œ© : Type*} (Y : Edge ‚Üí Œ© ‚Üí ‚Ñù) (œâ : Œ©) :
    2 * n * h N (T_Gumbel n n Y œâ / (2 * n)) ‚â§ T_Approx n n N Y œâ - T_Gumbel n n Y œâ := by
      rcases eq_or_ne n 0 with ( rfl | hn ) <;> norm_num at *;
      ¬∑ unfold T_Gumbel T_Approx;
        unfold LPP_value; aesop;
        refine' le_trans _ ( Finset.le_max' _ _ <| Finset.mem_image_of_mem _ a_1 ) ; aesop;
        -- Since $h_N(x)$ is non-negative for all $x$, the sum of $h_N(Y_i \omega)$ over any path is also non-negative.
        have h_nonneg : ‚àÄ x : ‚Ñù, 0 ‚â§ h N x := by
          exact fun x => by have := lemma_1 N hN; exact this.2.1 x |>.1.le;
        exact List.sum_nonneg ( by aesop );
      ¬∑ -- Let's denote the geodesic (maximizing path) for $T_{Gumbel}$ as $\pi^*$.
        obtain ‚ü®pi_star, h_pi_star‚ü© : ‚àÉ pi_star : GridPath, IsValidPath (0, 0) (n, n) pi_star ‚àß (pi_star.map (fun e => Y e œâ)).sum = T_Gumbel n n Y œâ := by
          have h_exists_pi_star : ‚àÉ pi_star ‚àà paths n n, (pi_star.map (fun e => Y e œâ)).sum = T_Gumbel n n Y œâ := by
            have := Finset.max'_mem ( Finset.image ( fun p : GridPath => ( p.map ( fun e => Y e œâ ) ).sum ) ( paths n n ) ) ‚ü® _, Finset.mem_image_of_mem _ ( Classical.choose_spec ( paths_nonempty n n ) ) ‚ü© ; aesop;
          unfold paths at h_exists_pi_star; aesop;
        -- By Jensen's inequality and convexity of $h_N$, we have $\frac{1}{2n} \sum_{e \in \pi^*} h_N(Y_e) \ge h_N(\frac{1}{2n} \sum_{e \in \pi^*} Y_e)$.
        have h_jensen : (pi_star.map (fun e => h N (Y e œâ))).sum ‚â• 2 * n * h N ((pi_star.map (fun e => Y e œâ)).sum / (2 * n)) := by
          -- Since $\pi^*$ is a valid path from $(0,0)$ to $(n,n)$, it has length $2n$.
          have h_pi_star_length : (pi_star.length : ‚Ñù) = 2 * n := by
            have h_pi_star_length : ‚àÄ {p q : GridPoint} {l : GridPath}, IsValidPath p q l ‚Üí (l.length : ‚Ñù) = q.1 + q.2 - p.1 - p.2 := by
              intros p q l hl; induction hl <;> aesop;
              cases h_edge <;> aesop <;> linarith;
            exact h_pi_star_length h_pi_star.1 ‚ñ∏ by push_cast; ring;
          have h_jensen : ‚àÄ (f : ‚Ñù ‚Üí ‚Ñù), ConvexOn ‚Ñù (Set.univ : Set ‚Ñù) f ‚Üí ‚àÄ (x : List ‚Ñù), x.length = 2 * n ‚Üí (List.map f x).sum ‚â• 2 * n * f ((List.sum x) / (2 * n)) := by
            intros f hf x hx_length
            have h_jensen : (‚àë i ‚àà Finset.range (2 * n), f (x.get! i)) ‚â• 2 * n * f ((‚àë i ‚àà Finset.range (2 * n), x.get! i) / (2 * n)) := by
              have h_jensen : (‚àë i ‚àà Finset.range (2 * n), (1 / (2 * n)) * f (x.get! i)) ‚â• f ((‚àë i ‚àà Finset.range (2 * n), (1 / (2 * n)) * x.get! i)) := by
                apply ConvexOn.map_sum_le hf;
                ¬∑ exact fun _ _ => by positivity;
                ¬∑ simp +decide [ hn ];
                  ring_nf; norm_num [ hn ];
                ¬∑ exact fun _ _ => Set.mem_univ _;
              simp_all +decide [ div_eq_inv_mul, ‚Üê Finset.mul_sum _ _ _ ];
              convert mul_le_mul_of_nonneg_left h_jensen ( show ( 0 : ‚Ñù ) ‚â§ 2 * n by positivity ) using 1 ; ring_nf ; norm_num [ hn ];
            convert h_jensen using 1;
            ¬∑ rw [ ‚Üê hx_length, Finset.sum_range ];
              simp +decide [ List.sum_eq_foldr, Finset.sum_range, List.get! ];
            ¬∑ norm_num [ ‚Üê hx_length, Finset.sum_range, List.get! ];
          convert h_jensen ( fun x => h N x ) ( lemma_1 N hN |>.1 ) ( List.map ( fun e => Y e œâ ) pi_star ) _ using 1;
          ¬∑ rw [ List.map_map ];
            rfl;
          ¬∑ simpa using mod_cast h_pi_star_length;
        -- Since $\pi^*$ is a valid path, we have $T_{Approx} \ge S_B(\pi^*) + T_{Gumbel}$.
        have h_approx_ge : T_Approx n n N Y œâ ‚â• (pi_star.map (fun e => h N (Y e œâ) + Y e œâ)).sum := by
          refine' Finset.le_max' _ _ _;
          unfold paths; aesop;
        simp_all +decide [ List.sum_map_add ];
        linarith

/-
Definitions of the properties representing known results from the paper.
-/
open Filter Topology MeasureTheory ProbabilityTheory

def ExactGumbelConvergenceProperty : Prop :=
  ‚àÄ (r : ‚Ñù),
  ‚àÄ {Œ© : ‚Ñï ‚Üí Type*} [‚àÄ n, MeasurableSpace (Œ© n)] (Œº : ‚àÄ n, Measure (Œ© n)) (Y : ‚àÄ n, Edge ‚Üí Œ© n ‚Üí ‚Ñù),
  (‚àÄ n, IsGumbelGrid (Œº n) (Y n)) ‚Üí
  Tendsto (fun n => ((Œº n) {œâ | (T_Gumbel n n (Y n) œâ - C_g * n) / (sigma_g * (n : ‚Ñù) ^ (1/3 : ‚Ñù)) ‚â§ r}).toReal) atTop (ùìù (F_GUE r))

def TimeConstantGumbelProperty : Prop :=
  ‚àÉ D_ell > 0, ‚àÄ {Œ© : ‚Ñï ‚Üí Type*} [‚àÄ n, MeasurableSpace (Œ© n)] (Œº : ‚àÄ n, Measure (Œ© n)) (Y : ‚àÄ n, Edge ‚Üí Œ© n ‚Üí ‚Ñù),
  (‚àÄ n, IsGumbelGrid (Œº n) (Y n)) ‚Üí
  ‚àÄ Œµ > 0, Tendsto (fun n => ((Œº n) {œâ | |T_Gumbel n n (Y n) œâ / n - D_ell| > Œµ}).toReal) atTop (ùìù 0)

def TimeConstantExpProperty : Prop :=
  ‚àÉ D_L > 0, ‚àÄ {Œ© : ‚Ñï ‚Üí Type*} [‚àÄ n, MeasurableSpace (Œ© n)] (Œº : ‚àÄ n, Measure (Œ© n)) (E : ‚àÄ n, Edge ‚Üí Œ© n ‚Üí ‚Ñù),
  (‚àÄ n, iIndepFun (E n) (Œº n) ‚àß ‚àÄ e x, (Œº n) {œâ | E n e œâ ‚â§ x} = ENNReal.ofReal (if 0 ‚â§ x then 1 - Real.exp (-x) else 0)) ‚Üí
  ‚àÄ Œµ > 0, Tendsto (fun n => ((Œº n) {œâ | |L_Exp n n (E n) œâ / n - D_L| > Œµ}).toReal) atTop (ùìù 0)

/-
Definition of convergence in probability to 0.
-/
/-- Convergence in probability to 0. -/
def ConvergesInProbZero {Œ© : ‚Ñï ‚Üí Type*} [‚àÄ n, MeasurableSpace (Œ© n)] (Œº : ‚àÄ n, Measure (Œ© n)) (Y : ‚àÄ n, Œ© n ‚Üí ‚Ñù) : Prop :=
  ‚àÄ Œµ > 0, Tendsto (fun n => ((Œº n) {œâ | |Y n œâ| > Œµ}).toReal) atTop (ùìù 0)

/-
Upper bound inequality for Slutsky's theorem.
-/
theorem slutsky_upper_bound {Œ© : Type*} [MeasurableSpace Œ©] (Œº : Measure Œ©)
    (X Y : Œ© ‚Üí ‚Ñù) (r Œµ : ‚Ñù) :
    Œº {œâ | X œâ + Y œâ ‚â§ r} ‚â§ Œº {œâ | X œâ ‚â§ r + Œµ} + Œº {œâ | |Y œâ| > Œµ} := by
      refine' le_trans ( MeasureTheory.measure_mono _ ) ( MeasureTheory.measure_union_le _ _ );
      intro œâ hœâ; contrapose! hœâ; aesop; cases abs_cases ( Y œâ ) <;> linarith;

/-
Lower bound inequality for Slutsky's theorem.
-/
theorem slutsky_lower_bound {Œ© : Type*} [MeasurableSpace Œ©] (Œº : Measure Œ©)
    (X Y : Œ© ‚Üí ‚Ñù) (r Œµ : ‚Ñù) :
    Œº {œâ | X œâ ‚â§ r - Œµ} ‚â§ Œº {œâ | X œâ + Y œâ ‚â§ r} + Œº {œâ | |Y œâ| > Œµ} := by
      refine' le_trans _ ( MeasureTheory.measure_union_le _ _ );
      refine' MeasureTheory.measure_mono fun œâ hœâ => _;
      norm_num +zetaDelta at *;
      contrapose! hœâ; cases abs_cases ( Y œâ ) <;> linarith;

/-
If $a_n \le b_n + c_n$, $b_n \to B$, and $c_n \to 0$, then eventually $a_n \le B + \epsilon$.
-/
lemma limit_upper_bound_helper (a b c : ‚Ñï ‚Üí ‚Ñù) (B : ‚Ñù)
    (hb : Tendsto b atTop (ùìù B))
    (hc : Tendsto c atTop (ùìù 0))
    (h_le : ‚àÄ n, a n ‚â§ b n + c n) :
    ‚àÄ Œµ > 0, ‚àÄ·∂† n in atTop, a n ‚â§ B + Œµ := by
      intro Œµ hŒµ; filter_upwards [ hb.eventually ( Metric.ball_mem_nhds B <| half_pos hŒµ ), hc.eventually ( Metric.ball_mem_nhds _ <| half_pos hŒµ ) ] with n hn hn' using by linarith [ h_le n, abs_lt.mp <| Metric.mem_ball.mp hn, abs_lt.mp <| Metric.mem_ball.mp hn' ] ;

/-
Upper bound direction for Slutsky's theorem.
-/
theorem slutsky_cdf_upper {Œ© : ‚Ñï ‚Üí Type*} [‚àÄ n, MeasurableSpace (Œ© n)] (Œº : ‚àÄ n, Measure (Œ© n)) [‚àÄ n, IsProbabilityMeasure (Œº n)]
    (X Y : ‚àÄ n, Œ© n ‚Üí ‚Ñù) (F : ‚Ñù ‚Üí ‚Ñù)
    (h_cont : Continuous F)
    (h_X : ‚àÄ r, Tendsto (fun n => ((Œº n) {œâ | X n œâ ‚â§ r}).toReal) atTop (ùìù (F r)))
    (h_Y : ConvergesInProbZero Œº Y)
    (r : ‚Ñù) :
    ‚àÄ Œµ > 0, ‚àÄ·∂† n in atTop, ((Œº n) {œâ | X n œâ + Y n œâ ‚â§ r}).toReal ‚â§ F r + Œµ := by
      -- For any $\epsilon > 0$, choose $\delta > 0$ such that $F(r + \delta) < F(r) + \epsilon / 2$.
      intro Œµ hŒµ_pos
      obtain ‚ü®Œ¥, hŒ¥_pos, hŒ¥‚ü© : ‚àÉ Œ¥ > 0, F (r + Œ¥) < F r + Œµ / 2 := by
        have := Metric.continuous_iff.mp h_cont r ( Œµ / 2 ) ( half_pos hŒµ_pos ) ; aesop;
        exact ‚ü® w / 2, half_pos left, by linarith [ abs_lt.mp ( right ( r + w / 2 ) ( abs_lt.mpr ‚ü® by linarith, by linarith ‚ü© ) ) ] ‚ü©;
      -- By `slutsky_upper_bound` with $\delta$, we have $\mu(\dots) \le \mu(\dots) + \mu(\dots)$ in ENNReal.
      have h_upper_bound : ‚àÄ n, ((Œº n) {œâ | X n œâ + Y n œâ ‚â§ r}).toReal ‚â§ ((Œº n) {œâ | X n œâ ‚â§ r + Œ¥}).toReal + ((Œº n) {œâ | |Y n œâ| > Œ¥}).toReal := by
        intro n;
        convert ENNReal.toReal_mono _ ( slutsky_upper_bound ( Œº n ) ( X n ) ( Y n ) r Œ¥ ) using 1;
        ¬∑ rw [ ENNReal.toReal_add ] <;> norm_num;
        ¬∑ exact ne_of_lt ( ENNReal.add_lt_top.mpr ‚ü® MeasureTheory.measure_lt_top _ _, MeasureTheory.measure_lt_top _ _ ‚ü© );
      have := h_X ( r + Œ¥ );
      filter_upwards [ this.eventually ( gt_mem_nhds <| show F ( r + Œ¥ ) < F r + Œµ / 2 by linarith ), h_Y Œ¥ hŒ¥_pos |> fun h => h.eventually ( gt_mem_nhds <| show ( 0 : ‚Ñù ) < Œµ / 2 by linarith ) ] with n hn hn' using by linarith [ h_upper_bound n ] ;

/-
Real-valued version of Slutsky upper bound inequality.
-/
theorem slutsky_upper_bound_real {Œ© : Type*} [MeasurableSpace Œ©] (Œº : Measure Œ©) [IsFiniteMeasure Œº]
    (X Y : Œ© ‚Üí ‚Ñù) (r Œµ : ‚Ñù) :
    (Œº {œâ | X œâ + Y œâ ‚â§ r}).toReal ‚â§ (Œº {œâ | X œâ ‚â§ r + Œµ}).toReal + (Œº {œâ | |Y œâ| > Œµ}).toReal := by
      have := @slutsky_upper_bound Œ© _ Œº X Y r Œµ ; aesop;
      convert ENNReal.toReal_mono _ this using 1 <;> norm_num [ ENNReal.toReal_add ]

/-
If $a_n \ge b_n - c_n$, $b_n \to B$, and $c_n \to 0$, then eventually $a_n \ge B - \epsilon$.
-/
lemma limit_lower_bound_helper (a b c : ‚Ñï ‚Üí ‚Ñù) (B : ‚Ñù)
    (hb : Tendsto b atTop (ùìù B))
    (hc : Tendsto c atTop (ùìù 0))
    (h_ge : ‚àÄ n, a n ‚â• b n - c n) :
    ‚àÄ Œµ > 0, ‚àÄ·∂† n in atTop, a n ‚â• B - Œµ := by
      intro Œµ hŒµ;
      filter_upwards [ hb.eventually ( Metric.ball_mem_nhds _ ( half_pos hŒµ ) ), hc.eventually ( Metric.ball_mem_nhds _ ( half_pos hŒµ ) ) ] with n hn hb using by linarith [ abs_lt.mp hn, abs_lt.mp hb, h_ge n ] ;

/-
Lower bound direction for Slutsky's theorem.
-/
theorem slutsky_cdf_lower {Œ© : ‚Ñï ‚Üí Type*} [‚àÄ n, MeasurableSpace (Œ© n)] (Œº : ‚àÄ n, Measure (Œ© n)) [‚àÄ n, IsProbabilityMeasure (Œº n)]
    (X Y : ‚àÄ n, Œ© n ‚Üí ‚Ñù) (F : ‚Ñù ‚Üí ‚Ñù)
    (h_cont : Continuous F)
    (h_X : ‚àÄ r, Tendsto (fun n => ((Œº n) {œâ | X n œâ ‚â§ r}).toReal) atTop (ùìù (F r)))
    (h_Y : ConvergesInProbZero Œº Y)
    (r : ‚Ñù) :
    ‚àÄ Œµ > 0, ‚àÄ·∂† n in atTop, ((Œº n) {œâ | X n œâ + Y n œâ ‚â§ r}).toReal ‚â• F r - Œµ := by
      aesop;
      -- Fix $\delta > 0$ such that $F(r - \delta) > F(r) - \frac{\epsilon}{2}$.
      obtain ‚ü®Œ¥, hŒ¥_pos, hŒ¥‚ü© : ‚àÉ Œ¥ > 0, F r - Œµ / 2 < F (r - Œ¥) := by
        have := Metric.continuous_iff.1 h_cont ( r ) ( Œµ / 2 ) ( half_pos a ) ; aesop;
        exact ‚ü® w / 2, half_pos left, by linarith [ abs_lt.mp ( right ( r - w / 2 ) ( abs_lt.mpr ‚ü® by linarith, by linarith ‚ü© ) ) ] ‚ü©;
      -- By `slutsky_lower_bound` with $\delta$, we have $b_n \le a_n + c_n$, so $a_n \ge b_n - c_n$.
      have h_lower_bound : ‚àÄ n, (((Œº n) {œâ | (X n œâ) ‚â§ r - Œ¥}).toReal) ‚â§ (((Œº n) {œâ | (X n œâ) + (Y n œâ) ‚â§ r}).toReal) + (((Œº n) {œâ | |(Y n œâ)| > Œ¥}).toReal) := by
        have h_lower_bound : ‚àÄ n, (Œº n) {œâ | (X n œâ) ‚â§ r - Œ¥} ‚â§ (Œº n) {œâ | (X n œâ) + (Y n œâ) ‚â§ r} + (Œº n) {œâ | |(Y n œâ)| > Œ¥} := by
          exact?;
        intro n; specialize h_lower_bound n; rw [ ‚Üê ENNReal.toReal_add ] ; aesop;
        ¬∑ exact MeasureTheory.measure_ne_top _ _;
        ¬∑ exact MeasureTheory.measure_ne_top _ _;
      -- We have $b_n \to F(r - \delta)$ (by `h_X`) and $c_n \to 0$ (by `h_Y`).
      have h_b_c : Filter.Tendsto (fun n => (((Œº n) {œâ | (X n œâ) ‚â§ r - Œ¥}).toReal)) Filter.atTop (ùìù (F (r - Œ¥))) ‚àß Filter.Tendsto (fun n => (((Œº n) {œâ | |(Y n œâ)| > Œ¥}).toReal)) Filter.atTop (ùìù 0) := by
        exact ‚ü® h_X _, by simpa using h_Y Œ¥ hŒ¥_pos ‚ü©;
      rcases Metric.tendsto_atTop.mp h_b_c.1 ( Œµ / 4 ) ( by linarith ) with ‚ü® N‚ÇÅ, hN‚ÇÅ ‚ü© ; rcases Metric.tendsto_atTop.mp h_b_c.2 ( Œµ / 4 ) ( by linarith ) with ‚ü® N‚ÇÇ, hN‚ÇÇ ‚ü© ; exact ‚ü® Max.max N‚ÇÅ N‚ÇÇ, fun n hn => by linarith [ abs_lt.mp ( hN‚ÇÅ n ( le_trans ( le_max_left _ _ ) hn ) ), abs_lt.mp ( hN‚ÇÇ n ( le_trans ( le_max_right _ _ ) hn ) ), h_lower_bound n ] ‚ü©

/-
Slutsky's theorem for CDFs.
-/
theorem slutsky_cdf {Œ© : ‚Ñï ‚Üí Type*} [‚àÄ n, MeasurableSpace (Œ© n)] (Œº : ‚àÄ n, Measure (Œ© n)) [‚àÄ n, IsProbabilityMeasure (Œº n)]
    (X Y : ‚àÄ n, Œ© n ‚Üí ‚Ñù) (F : ‚Ñù ‚Üí ‚Ñù)
    (h_cont : Continuous F)
    (h_X : ‚àÄ r, Tendsto (fun n => ((Œº n) {œâ | X n œâ ‚â§ r}).toReal) atTop (ùìù (F r)))
    (h_Y : ConvergesInProbZero Œº Y) :
    ‚àÄ r, Tendsto (fun n => ((Œº n) {œâ | X n œâ + Y n œâ ‚â§ r}).toReal) atTop (ùìù (F r)) := by
      intro r
      have h_upper : ‚àÄ Œµ > 0, ‚àÄ·∂† n in atTop, ((Œº n) {œâ | X n œâ + Y n œâ ‚â§ r}).toReal ‚â§ F r + Œµ := by
        exact?
      have h_lower : ‚àÄ Œµ > 0, ‚àÄ·∂† n in atTop, ((Œº n) {œâ | X n œâ + Y n œâ ‚â§ r}).toReal ‚â• F r - Œµ := by
        exact?
      exact (by
      rw [ Metric.tendsto_nhds ];
      exact fun Œµ Œµpos => by filter_upwards [ h_upper ( Œµ / 2 ) ( half_pos Œµpos ), h_lower ( Œµ / 2 ) ( half_pos Œµpos ) ] with n hn‚ÇÅ hn‚ÇÇ using abs_lt.mpr ‚ü® by linarith, by linarith ‚ü© ;)

/-
Definition of convergence in probability to a constant.
-/
/-- Convergence in probability to a constant. -/
def ConvergesInProbConst {Œ© : ‚Ñï ‚Üí Type*} [‚àÄ n, MeasurableSpace (Œ© n)] (Œº : ‚àÄ n, Measure (Œ© n)) (Y : ‚àÄ n, Œ© n ‚Üí ‚Ñù) (c : ‚Ñù) : Prop :=
  ‚àÄ Œµ > 0, Tendsto (fun n => ((Œº n) {œâ | |Y n œâ - c| > Œµ}).toReal) atTop (ùìù 0)

/-
If $|y| > |c| + 1$, then $|y - c| > 1$.
-/
lemma abs_gt_of_abs_sub_gt (y c : ‚Ñù) : |y| > |c| + 1 ‚Üí |y - c| > 1 := by
  cases abs_cases ( y - c ) <;> cases abs_cases y <;> cases abs_cases c <;> intros <;> linarith

/-
If $Y_n \to c$ in probability, then $P(|Y_n| > |c| + 1) \to 0$.
-/
lemma converges_in_prob_bounded {Œ© : ‚Ñï ‚Üí Type*} [‚àÄ n, MeasurableSpace (Œ© n)] (Œº : ‚àÄ n, Measure (Œ© n)) [‚àÄ n, IsFiniteMeasure (Œº n)]
    (Y : ‚àÄ n, Œ© n ‚Üí ‚Ñù) (c : ‚Ñù)
    (h : ConvergesInProbConst Œº Y c) :
    Tendsto (fun n => ((Œº n) {œâ | |Y n œâ| > |c| + 1}).toReal) atTop (ùìù 0) := by
      have h_bound : ‚àÄ n, ((Œº n) {œâ | |Y n œâ| > |c| + 1}).toReal ‚â§ ((Œº n) {œâ | |Y n œâ - c| > 1}).toReal := by
        intro n; apply_rules [ ENNReal.toReal_mono, MeasureTheory.measure_mono ] ; aesop;
        exact fun œâ hœâ => by norm_num at *; cases abs_cases ( Y n œâ ) <;> cases abs_cases c <;> cases abs_cases ( Y n œâ - c ) <;> linarith;
      exact squeeze_zero ( fun n => ENNReal.toReal_nonneg ) h_bound ( by simpa using h 1 zero_lt_one )

/-
Product of a sequence converging in probability to a constant and a sequence converging to 0 converges in probability to 0.
-/
lemma converges_in_prob_mul_zero {Œ© : ‚Ñï ‚Üí Type*} [‚àÄ n, MeasurableSpace (Œ© n)] (Œº : ‚àÄ n, Measure (Œ© n)) [‚àÄ n, IsFiniteMeasure (Œº n)]
    (Y : ‚àÄ n, Œ© n ‚Üí ‚Ñù) (c : ‚Ñù) (a : ‚Ñï ‚Üí ‚Ñù)
    (h_Y : ConvergesInProbConst Œº Y c)
    (h_a : Tendsto a atTop (ùìù 0)) :
    ConvergesInProbZero Œº (fun n œâ => a n * Y n œâ) := by
      intro Œµ hŒµ;
      -- Fix $\epsilon > 0$. Since $a_n \to 0$, there exists $N$ such that for all $n \ge N$, $|a_n| < \frac{\epsilon}{|c| + 1}$.
      obtain ‚ü®N, hN‚ü© : ‚àÉ N, ‚àÄ n ‚â• N, |a n| < Œµ / (|c| + 1) := by
        simpa using h_a.eventually ( Metric.ball_mem_nhds _ <| by positivity );
      -- For such $n$, if $|Y_n| \le |c| + 1$, then $|a_n Y_n| < \frac{\epsilon}{|c| + 1} (|c| + 1) = \epsilon$.
      have h_bound : ‚àÄ n ‚â• N, {œâ | Œµ < |a n * Y n œâ|} ‚äÜ {œâ | |Y n œâ| > |c| + 1} := by
        intro n hn œâ hœâ; specialize hN n hn; rw [ lt_div_iff‚ÇÄ ( by positivity ) ] at hN; contrapose! hœâ; aesop;
        exact le_trans ( mul_le_mul_of_nonneg_left hœâ ( abs_nonneg _ ) ) hN.le;
      -- Thus, for $n \ge N$, $\mu(\{|a_n Y_n| > \epsilon\}) \le \mu(\{|Y_n| > |c| + 1\})$.
      have h_measure_bound : ‚àÄ n ‚â• N, ((Œº n) {œâ | Œµ < |a n * Y n œâ|}).toReal ‚â§ ((Œº n) {œâ | |Y n œâ| > |c| + 1}).toReal := by
        exact fun n hn => ENNReal.toReal_mono ( MeasureTheory.measure_ne_top _ _ ) ( MeasureTheory.measure_mono ( h_bound n hn ) );
      exact squeeze_zero_norm' ( Filter.eventually_atTop.mpr ‚ü® N, fun n hn => by rw [ Real.norm_of_nonneg ( by positivity ) ] ; exact h_measure_bound n hn ‚ü© ) ( converges_in_prob_bounded Œº Y c h_Y )

/-
If $0 \le X \le Z$, then $P(|X| > \epsilon) \le P(|Z| > \epsilon)$.
-/
lemma squeeze_measure_le {Œ© : Type*} [MeasurableSpace Œ©] (Œº : Measure Œ©)
    (X Z : Œ© ‚Üí ‚Ñù) (Œµ : ‚Ñù)
    (h_nonneg : ‚àÄ œâ, 0 ‚â§ X œâ)
    (h_le : ‚àÄ œâ, X œâ ‚â§ Z œâ) :
    Œº {œâ | |X œâ| > Œµ} ‚â§ Œº {œâ | |Z œâ| > Œµ} := by
      apply_rules [ MeasureTheory.measure_mono ];
      aesop;
      cases abs_cases ( X a ) <;> cases abs_cases ( Z a ) <;> linarith [ h_nonneg a, h_le a ]

/-
The deterministic factor in the error term converges to 0.
-/
lemma deterministic_factor_limit (Œ± : ‚Ñù) (h_alpha : Œ± > 2/3) :
    Tendsto (fun n => (n : ‚Ñù) / (Nat.floor ((n : ‚Ñù) ^ Œ±) * (n : ‚Ñù) ^ (1/3 : ‚Ñù))) atTop (ùìù 0) := by
      -- We can factor out $n^{1/3}$ from the denominator and use the fact that $‚åän^\alpha‚åã‚Çä$ is approximately $n^\alpha$ for large $n$.
      have h_factor : Tendsto (fun n => (n : ‚Ñù) ^ (1 - Œ± - 1 / 3 : ‚Ñù)) Filter.atTop (nhds 0) := by
        simpa using tendsto_rpow_neg_atTop ( by linarith : 0 < - ( 1 - Œ± - 1 / 3 ) );
      -- Using the fact that $‚åän^\alpha‚åã‚Çä$ is approximately $n^\alpha$ for large $n$, we can bound the expression.
      have h_bound : ‚àÄ·∂† n in Filter.atTop, (n : ‚Ñù) / (‚åän ^ Œ±‚åã‚Çä * n ^ (1 / 3 : ‚Ñù)) ‚â§ 2 * (n : ‚Ñù) ^ (1 - Œ± - 1 / 3 : ‚Ñù) := by
        -- Using the fact that $‚åän^\alpha‚åã‚Çä$ is approximately $n^\alpha$ for large $n$, we can bound the expression as follows:
        have h_bound : ‚àÄ·∂† n in Filter.atTop, (n : ‚Ñù) / (‚åän ^ Œ±‚åã‚Çä * n ^ (1 / 3 : ‚Ñù)) ‚â§ (n : ‚Ñù) / ((n ^ Œ± / 2) * n ^ (1 / 3 : ‚Ñù)) := by
          filter_upwards [ Filter.eventually_gt_atTop 1, Filter.eventually_gt_atTop ( 2 ^ ( 1 / Œ± ) ) ] with n hn hn';
          gcongr;
          linarith [ Nat.lt_floor_add_one ( n ^ Œ± ), show ( n : ‚Ñù ) ^ Œ± ‚â• 2 by exact le_trans ( by exact le_of_eq ( by rw [ ‚Üê Real.rpow_mul ( by positivity ), one_div_mul_cancel ( by positivity ), Real.rpow_one ] ) ) ( Real.rpow_le_rpow ( by positivity ) hn'.le ( by positivity ) ) ];
        filter_upwards [ h_bound, Filter.eventually_gt_atTop 0 ] with n hn hn' ; convert hn using 1 ; ring;
        rw [ show ( 2 / 3 - Œ± : ‚Ñù ) = 1 - Œ± - 1 / 3 by ring, Real.rpow_sub hn', Real.rpow_sub hn' ] ; norm_num ; ring;
      refine' squeeze_zero_norm' _ _;
      exacts [ fun n => 2 * n ^ ( 1 - Œ± - 1 / 3 ), by filter_upwards [ h_bound, Filter.eventually_gt_atTop 0 ] with n hn hn' using by rw [ Real.norm_of_nonneg ( by positivity ) ] ; exact hn, by simpa using h_factor.const_mul 2 ]

/-
The difference between the approximate and exact LPP is non-negative and bounded by the exponential LPP scaled by 1/N.
-/
lemma coupling_ineq_lift (n : ‚Ñï) (N : ‚Ñù) (hN : 1 ‚â§ N) {Œ© : Type*} (Y : Edge ‚Üí Œ© ‚Üí ‚Ñù) (œâ : Œ©) :
    0 ‚â§ T_Approx n n N Y œâ - T_Gumbel n n Y œâ ‚àß
    T_Approx n n N Y œâ - T_Gumbel n n Y œâ ‚â§ (1 / N) * L_Exp n n (fun e œâ => Real.exp (- (Y e œâ))) œâ := by
      refine' ‚ü® _, _ ‚ü©;
      ¬∑ refine' le_trans _ ( coupling_lower_bound n N hN Y œâ );
        exact mul_nonneg ( by positivity ) ( lemma_1 N hN |>.2.1 _ |>.1.le );
      ¬∑ exact?

/-
Calculation of the transformed CDF for positive y.
-/
lemma gumbel_exp_neg_cdf_calc (y : ‚Ñù) (hy : 0 < y) :
    1 - gumbel_cdf (-Real.log y) = 1 - Real.exp (-y) := by
      unfold gumbel_cdf; norm_num [ Real.exp_neg, Real.exp_log hy ] ;

/-
The Gumbel CDF is continuous.
-/
lemma gumbel_cdf_continuous : Continuous gumbel_cdf := by
  exact Real.continuous_exp.comp <| Continuous.neg <| Real.continuous_exp.comp <| Continuous.neg continuous_id

/-
Set difference characterization of the interval (a, b].
-/
lemma set_Ioc_eq_diff {Œ© : Type*} (Y : Œ© ‚Üí ‚Ñù) (a b : ‚Ñù) :
    {œâ | a < Y œâ ‚àß Y œâ ‚â§ b} = {œâ | Y œâ ‚â§ b} \ {œâ | Y œâ ‚â§ a} := by
      ext œâ; aesop

/-
The CDF function F is monotone non-decreasing.
-/
lemma cdf_mono {Œ© : Type*} [MeasurableSpace Œ©] (Œº : Measure Œ©) (Y : Œ© ‚Üí ‚Ñù) (F : ‚Ñù ‚Üí ‚Ñù)
    (h_cdf : ‚àÄ x, Œº {œâ | Y œâ ‚â§ x} = ENNReal.ofReal (F x))
    (hF_nonneg : ‚àÄ x, 0 ‚â§ F x) :
    Monotone F := by
      -- By definition of F, we know that Œº {œâ | Y œâ ‚â§ x} = ENNReal.ofReal (F x) and Œº {œâ | Y œâ ‚â§ y} = ENNReal.ofReal (F y).
      have h_monotone : ‚àÄ x y, x ‚â§ y ‚Üí Œº {œâ | Y œâ ‚â§ x} ‚â§ Œº {œâ | Y œâ ‚â§ y} := by
        exact fun x y hxy => MeasureTheory.measure_mono fun œâ hœâ => le_trans hœâ.out hxy;
      aesop

/-
The measure of an interval (a, b] is F(b) - F(a), assuming Y is measurable.
-/
lemma measure_Ioc_eq_cdf_sub {Œ© : Type*} [MeasurableSpace Œ©] (Œº : Measure Œ©) (Y : Œ© ‚Üí ‚Ñù) (F : ‚Ñù ‚Üí ‚Ñù)
    (h_meas : Measurable Y)
    (h_cdf : ‚àÄ x, Œº {œâ | Y œâ ‚â§ x} = ENNReal.ofReal (F x))
    (hF_nonneg : ‚àÄ x, 0 ‚â§ F x)
    (a b : ‚Ñù) (hab : a < b) :
    Œº {œâ | a < Y œâ ‚àß Y œâ ‚â§ b} = ENNReal.ofReal (F b - F a) := by
      rw [ show { œâ | a < Y œâ ‚àß Y œâ ‚â§ b } = { œâ | Y œâ ‚â§ b } \ { œâ | Y œâ ‚â§ a } by ext; aesop, MeasureTheory.measure_diff ] <;> norm_num [ h_cdf ];
      ¬∑ rw [ ENNReal.ofReal_sub ] ; aesop;
      ¬∑ exact fun œâ hœâ => le_trans hœâ hab.le;
      ¬∑ exact measurableSet_le h_meas measurable_const |> MeasurableSet.nullMeasurableSet

/-
The measure of (a, b] is the difference of the measures of (-inf, b] and (-inf, a].
-/
lemma measure_Ioc_eq_measure_le_sub_measure_le {Œ© : Type*} [MeasurableSpace Œ©] (Œº : Measure Œ©) (Y : Œ© ‚Üí ‚Ñù)
    (h_meas : Measurable Y)
    (a b : ‚Ñù) (hab : a < b)
    (h_finite : Œº {œâ | Y œâ ‚â§ a} ‚â† ‚ä§) :
    Œº {œâ | a < Y œâ ‚àß Y œâ ‚â§ b} = Œº {œâ | Y œâ ‚â§ b} - Œº {œâ | Y œâ ‚â§ a} := by
      rw [ ‚Üê MeasureTheory.measure_diff ];
      ¬∑ exact congr_arg _ ( by ext; aesop );
      ¬∑ exact fun x hx => le_trans hx.out hab.le;
      ¬∑ exact h_meas.nullMeasurable measurableSet_Iic;
      ¬∑ assumption

/-
If a random variable has a continuous CDF at y, the probability it equals y is 0.
-/
lemma measure_singleton_eq_zero_of_continuous_cdf {Œ© : Type*} [MeasurableSpace Œ©] (Œº : Measure Œ©) (Y : Œ© ‚Üí ‚Ñù) (F : ‚Ñù ‚Üí ‚Ñù)
    (h_meas : Measurable Y)
    (y : ‚Ñù)
    (h_cdf : ‚àÄ x, Œº {œâ | Y œâ ‚â§ x} = ENNReal.ofReal (F x))
    (hF_nonneg : ‚àÄ x, 0 ‚â§ F x)
    (h_cont : ContinuousAt F y) :
    Œº {œâ | Y œâ = y} = 0 := by
      -- By the squeeze theorem, since $\mu(y - 1/(n+1) < Y \le y)$ tends to $0$ as $n$ tends to infinity, we have $\mu(Y = y) \le 0$.
      have h_squeeze : Filter.Tendsto (fun n : ‚Ñï => Œº {œâ | y - 1 / (n + 1) < Y œâ ‚àß Y œâ ‚â§ y}) Filter.atTop (nhds 0) := by
        -- By the properties of the CDF, we have $\mu(y - 1/(n+1) < Y \le y) = ENNReal.ofReal (F(y) - F(y - 1/(n+1)))$.
        have h_cdf_interval : ‚àÄ n : ‚Ñï, Œº {œâ | y - 1 / (n + 1) < Y œâ ‚àß Y œâ ‚â§ y} = ENNReal.ofReal (F y - F (y - 1 / (n + 1))) := by
          intro n;
          convert measure_Ioc_eq_cdf_sub Œº Y F h_meas h_cdf hF_nonneg ( y - 1 / ( n + 1 ) ) y ( sub_lt_self _ ( by positivity ) ) using 1;
        aesop;
        simpa using ENNReal.tendsto_ofReal ( Filter.Tendsto.const_sub ( F y ) ( h_cont.tendsto.comp ( show Filter.Tendsto ( fun n : ‚Ñï => y - ( n + 1 : ‚Ñù ) ‚Åª¬π ) Filter.atTop ( nhds y ) by exact le_trans ( tendsto_const_nhds.sub ( tendsto_inv_atTop_zero.comp ( Filter.tendsto_atTop_add_const_right _ _ tendsto_natCast_atTop_atTop ) ) ) ( by simp +decide ) ) ) );
      aesop;
      exact le_antisymm ( le_of_tendsto_of_tendsto' tendsto_const_nhds h_squeeze fun n => by exact MeasureTheory.measure_mono <| fun œâ hœâ => ‚ü® by linarith [ hœâ.symm, inv_pos.mpr ( by linarith : 0 < ( n : ‚Ñù ) + 1 ) ], by linarith [ hœâ.symm, inv_pos.mpr ( by linarith : 0 < ( n : ‚Ñù ) + 1 ) ] ‚ü© ) bot_le

/-
The difference F(y) - F(y - 1/(n+1)) tends to 0 if F is continuous at y.
-/
lemma cdf_diff_tendsto_zero (F : ‚Ñù ‚Üí ‚Ñù) (y : ‚Ñù) (h_cont : ContinuousAt F y) :
    Tendsto (fun n : ‚Ñï => F y - F (y - 1 / (n + 1))) atTop (nhds 0) := by
      simpa using h_cont.tendsto.comp ( show Filter.Tendsto ( fun n : ‚Ñï => y - ( n + 1 : ‚Ñù ) ‚Åª¬π ) Filter.atTop ( nhds y ) by simpa using tendsto_const_nhds.sub ( tendsto_one_div_add_atTop_nhds_zero_nat ) ) |> fun h => h.const_sub ( F y )

/-
The measure of a singleton for a Gumbel variable is 0.
-/
lemma gumbel_measure_singleton_zero {Œ© : Type*} [MeasurableSpace Œ©] (Œº : Measure Œ©) (Y : Œ© ‚Üí ‚Ñù)
    (h_meas : Measurable Y)
    (hY : ‚àÄ x, Œº {œâ | Y œâ ‚â§ x} = ENNReal.ofReal (gumbel_cdf x)) (y : ‚Ñù) :
    Œº {œâ | Y œâ = y} = 0 := by
      -- Apply the lemma that states if a random variable has a continuous CDF at y, then the probability it equals y is 0.
      apply measure_singleton_eq_zero_of_continuous_cdf Œº Y (fun x => gumbel_cdf x) h_meas y hY (fun x => by
        exact Real.exp_nonneg _) (by
      exact gumbel_cdf_continuous.continuousAt)

/-
The probability that a Gumbel variable is at least y is 1 - F(y).
-/
lemma gumbel_prob_ge {Œ© : Type*} [MeasurableSpace Œ©] (Œº : Measure Œ©) [IsProbabilityMeasure Œº] (Y : Œ© ‚Üí ‚Ñù)
    (h_meas : Measurable Y)
    (hY : ‚àÄ x, Œº {œâ | Y œâ ‚â§ x} = ENNReal.ofReal (gumbel_cdf x)) (y : ‚Ñù) :
    Œº {œâ | Y œâ ‚â• y} = ENNReal.ofReal (1 - gumbel_cdf y) := by
      -- Since $Y$ is measurable, the set ${œâ | y ‚â§ Y œâ}$ is the complement of ${œâ | Y œâ ‚â§ y}$.
      have h_compl : Œº {œâ | y ‚â§ Y œâ} = Œº Set.univ - Œº {œâ | Y œâ ‚â§ y} := by
        rw [ ‚Üê MeasureTheory.measure_diff ] <;> norm_num;
        ¬∑ rw [ ‚Üê MeasureTheory.measure_congr ];
          rw [ MeasureTheory.ae_eq_set ] ; aesop;
          ¬∑ exact MeasureTheory.measure_mono_null ( fun œâ => by aesop ; linarith ) ( MeasureTheory.measure_empty );
          ¬∑ rw [ show { œâ | y ‚â§ Y œâ } \ ( Set.univ \ { œâ | Y œâ ‚â§ y } ) = { œâ | y ‚â§ Y œâ ‚àß y ‚â§ Y œâ } ‚à© { œâ | Y œâ ‚â§ y } by ext; aesop ] ; exact MeasureTheory.measure_mono_null ( fun x => by aesop ; linarith ) ( gumbel_measure_singleton_zero Œº Y h_meas hY y );
        ¬∑ exact h_meas.nullMeasurable measurableSet_Iic;
      rw [ ENNReal.ofReal_sub ] <;> aesop;
      exact Real.exp_nonneg _

/-
Transformation of Gumbel CDF to Exponential CDF.
-/
lemma gumbel_to_exp_cdf {Œ© : Type*} [MeasurableSpace Œ©] (Œº : Measure Œ©) [IsProbabilityMeasure Œº] (Y : Œ© ‚Üí ‚Ñù)
    (h_meas : Measurable Y)
    (hY : ‚àÄ x, Œº {œâ | Y œâ ‚â§ x} = ENNReal.ofReal (gumbel_cdf x)) :
    ‚àÄ x, Œº {œâ | Real.exp (-Y œâ) ‚â§ x} = ENNReal.ofReal (if 0 ‚â§ x then 1 - Real.exp (-x) else 0) := by
      aesop;
      ¬∑ by_cases hx : x = 0;
        ¬∑ simp +decide [ hx, Real.exp_ne_zero ];
          exact MeasureTheory.measure_mono_null ( fun œâ hœâ => by linarith [ Real.exp_pos ( -Y œâ ), hœâ.out ] ) ( MeasureTheory.measure_empty );
        ¬∑ convert gumbel_prob_ge Œº Y h_meas hY ( -Real.log x ) using 1;
          ¬∑ congr with œâ ; aesop;
            ¬∑ linarith [ Real.log_exp ( -Y œâ ), Real.log_le_log ( by positivity ) a ];
            ¬∑ rw [ ‚Üê Real.log_le_log_iff ( by positivity ) ( by positivity ), Real.log_exp ] ; linarith;
          ¬∑ unfold gumbel_cdf; norm_num [ Real.exp_neg, Real.exp_log ( lt_of_le_of_ne h ( Ne.symm hx ) ) ] ;
      ¬∑ exact MeasureTheory.measure_mono_null ( fun œâ hœâ => by linarith [ hœâ.out, Real.exp_pos ( -Y œâ ) ] ) ( MeasureTheory.measure_empty )

/-
For positive x, the CDF of exp(-Y) matches the exponential distribution.
-/
lemma gumbel_to_exp_cdf_pos {Œ© : Type*} [MeasurableSpace Œ©] (Œº : Measure Œ©) [IsProbabilityMeasure Œº] (Y : Œ© ‚Üí ‚Ñù)
    (h_meas : Measurable Y)
    (hY : ‚àÄ x, Œº {œâ | Y œâ ‚â§ x} = ENNReal.ofReal (gumbel_cdf x))
    (x : ‚Ñù) (hx : 0 < x) :
    Œº {œâ | Real.exp (-Y œâ) ‚â§ x} = ENNReal.ofReal (1 - Real.exp (-x)) := by
      convert gumbel_to_exp_cdf Œº Y h_meas hY x using 1;
      rw [ if_pos hx.le ]

/-
For non-positive x, the probability that exp(-Y) <= x is 0.
-/
lemma gumbel_to_exp_cdf_nonpos {Œ© : Type*} [MeasurableSpace Œ©] (Œº : Measure Œ©) (Y : Œ© ‚Üí ‚Ñù)
    (x : ‚Ñù) (hx : x ‚â§ 0) :
    Œº {œâ | Real.exp (-Y œâ) ‚â§ x} = 0 := by
      exact MeasureTheory.measure_mono_null ( fun œâ hœâ => by linarith [ Real.exp_pos ( -Y œâ ), hœâ.out ] ) ( MeasureTheory.measure_empty )
