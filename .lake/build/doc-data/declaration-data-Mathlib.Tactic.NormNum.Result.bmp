{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.eqTrans\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Result</span>.<span class=\"name\">eqTrans</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">eq</span> : <span class=\"fn\">Q(<span class=\"fn\">«$a»</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">«$b»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">b</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">a</span></span></span></div></div>","info":{"doc":"If `a = b` and we can evaluate `b`, then we can evaluate `a`. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.eqTrans","kind":"def","line":561,"name":"Mathlib.Meta.NormNum.Result.eqTrans","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L561-L578"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.ofBoolResult\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Result</span>.<span class=\"name\">ofBoolResult</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">p</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Prop</a>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">b</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">prf</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.BoolResult\">BoolResult</a> <span class=\"fn\">p</span> <span class=\"fn\">b</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">q(<a href=\"./foundational_types.html\">Prop</a>)</span></span></div></div>","info":{"doc":"Obtain a `Result` from a `BoolResult`. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.ofBoolResult","kind":"def","line":557,"name":"Mathlib.Meta.NormNum.Result.ofBoolResult","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L557-L559"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.BoolResult\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">BoolResult</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Prop</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">b</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"Given `Mathlib.Meta.NormNum.Result.isBool p b`, this is the type of `p`.\nNote that `BoolResult p b` is definitionally equal to `Expr`, and if you write `match b with ...`,\nthen in the `true` branch `BoolResult p true` is reducibly equal to `Q($p)` and\nin the `false` branch it is reducibly equal to `Q(¬ $p)`. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.BoolResult","kind":"def","line":550,"name":"Mathlib.Meta.NormNum.BoolResult","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L550-L555"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.toSimpResult\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Result</span>.<span class=\"name\">toSimpResult</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">e</span></span> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span></span></div></div>","info":{"doc":"Convert a `Result` to a `Simp.Result`. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.toSimpResult","kind":"def","line":532,"name":"Mathlib.Meta.NormNum.Result.toSimpResult","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L532-L548"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.ofRawRat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Result</span>.<span class=\"name\">ofRawRat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">q</span> : <a href=\"./Init/Data/Rat/Basic.html#Rat\">ℚ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hyp</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> := <a href=\"./Init/Prelude.html#Option.none\">none</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">e</span></span></div></div>","info":{"doc":"Constructs a `Result` out of a raw rat cast.\nAssumes `e` is a raw rat cast expression denoting `n`. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.ofRawRat","kind":"def","line":519,"name":"Mathlib.Meta.NormNum.Result.ofRawRat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L519-L530"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.ofRawNNRat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Result</span>.<span class=\"name\">ofRawNNRat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">q</span> : <a href=\"./Init/Data/Rat/Basic.html#Rat\">ℚ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hyp</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> := <a href=\"./Init/Prelude.html#Option.none\">none</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">e</span></span></div></div>","info":{"doc":"Constructs a `Result` out of a raw rat cast.\nAssumes `e` is a raw rat cast expression denoting `n`. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.ofRawNNRat","kind":"def","line":507,"name":"Mathlib.Meta.NormNum.Result.ofRawNNRat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L507-L517"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.ofRawInt\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Result</span>.<span class=\"name\">ofRawInt</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">e</span></span></div></div>","info":{"doc":"Constructs a `Result` out of a raw int cast.\nAssumes `e` is a raw int cast expression denoting `n`. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.ofRawInt","kind":"def","line":498,"name":"Mathlib.Meta.NormNum.Result.ofRawInt","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L498-L505"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.ofRawNat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Result</span>.<span class=\"name\">ofRawNat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">e</span></span></div></div>","info":{"doc":"Constructs a `Result` out of a raw nat cast. Assumes `e` is a raw nat cast expression. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.ofRawNat","kind":"def","line":493,"name":"Mathlib.Meta.NormNum.Result.ofRawNat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L493-L496"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.toRawIntEq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Result</span>.<span class=\"name\">toRawIntEq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">e</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> (<a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">(<span class=\"fn\">e'</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>) × <span class=\"fn\">Q(<span class=\"fn\">«$e»</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">«$e'»</span>)</span></span>)</span></span></div></div>","info":{"doc":"`Result.toRawEq` but providing an integer. Given a `NormNum.Result e` for something known to be an\ninteger (which uses `IsNat` or `IsInt` to express equality to an integer numeral), converts it to\nan equality `e = Nat.rawCast n` or `e = Int.rawCast n` to a raw cast expression, so it can be used\nfor rewriting. Gives `none` if not an integer.\n","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.toRawIntEq","kind":"def","line":481,"name":"Mathlib.Meta.NormNum.Result.toRawIntEq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L481-L491"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.toRawEq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Result</span>.<span class=\"name\">toRawEq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">e</span></span> → <span class=\"fn\">(<span class=\"fn\">e'</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>) × <span class=\"fn\">Q(<span class=\"fn\">«$e»</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">«$e'»</span>)</span></span></span></div></div>","info":{"doc":"Given a `NormNum.Result e` (which uses `IsNat`, `IsInt`, `IsRat` to express equality to a rational\nnumeral), converts it to an equality `e = Nat.rawCast n`, `e = Int.rawCast n`, or\n`e = Rat.rawCast n d` to a raw cast expression, so it can be used for rewriting.\n","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.toRawEq","kind":"def","line":464,"name":"Mathlib.Meta.NormNum.Result.toRawEq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L464-L479"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.toRat'\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Result</span>.<span class=\"name\">toRat'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">_i</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#DivisionRing\">DivisionRing</a> <span class=\"fn\">«$α»</span></span>)</span> := by with_reducible assumption)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">e</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> (<a href=\"./Init/Data/Rat/Basic.html#Rat\">ℚ</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">(<span class=\"fn\">n</span> : <span class=\"fn\">Q(<a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span>) × <span class=\"fn\">(<span class=\"fn\">d</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>) × <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsRat\">IsRat</a> <span class=\"fn\">«$e»</span> <span class=\"fn\">«$n»</span> <span class=\"fn\">«$d»</span></span>)</span></span></span>)</span></span></div></div>","info":{"doc":"Extract from a `Result` the rational value (as both a term and an expression),\nand the proof that the original expression is equal to this rational number.\n","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.toRat'","kind":"def","line":444,"name":"Mathlib.Meta.NormNum.Result.toRat'","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L444-L462"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.toNNRat'\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Result</span>.<span class=\"name\">toNNRat'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">_i</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#DivisionSemiring\">DivisionSemiring</a> <span class=\"fn\">«$α»</span></span>)</span> := by with_reducible assumption)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">e</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> (<a href=\"./Init/Data/Rat/Basic.html#Rat\">ℚ</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">(<span class=\"fn\">n</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>) × <span class=\"fn\">(<span class=\"fn\">d</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>) × <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNNRat\">IsNNRat</a> <span class=\"fn\">«$e»</span> <span class=\"fn\">«$n»</span> <span class=\"fn\">«$d»</span></span>)</span></span></span>)</span></span></div></div>","info":{"doc":"Extract from a `Result` the rational value (as both a term and an expression),\nand the proof that the original expression is equal to this rational number.\n","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.toNNRat'","kind":"def","line":431,"name":"Mathlib.Meta.NormNum.Result.toNNRat'","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L431-L442"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.toInt\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Result</span>.<span class=\"name\">toInt</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">_i</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">«$α»</span></span>)</span> := by with_reducible assumption)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">e</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> (<a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">(<span class=\"fn\">lit</span> : <span class=\"fn\">Q(<a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span>) × <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt\">IsInt</a> <span class=\"fn\">«$e»</span> <span class=\"fn\">«$lit»</span></span>)</span></span>)</span></span></div></div>","info":{"doc":"Extract from a `Result` the integer value (as both a term and an expression),\nand the proof that the original expression is equal to this integer.\n","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.toInt","kind":"def","line":419,"name":"Mathlib.Meta.NormNum.Result.toInt","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L419-L429"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.toRatNZ\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Result</span>.<span class=\"name\">toRatNZ</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">e</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> (<a href=\"./Init/Data/Rat/Basic.html#Rat\">ℚ</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span></div></div>","info":{"doc":"Returns the rational number that is the result of `norm_num` evaluation, along with a proof\nthat the denominator is nonzero in the `isRat` case. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.toRatNZ","kind":"def","line":410,"name":"Mathlib.Meta.NormNum.Result.toRatNZ","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L410-L417"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.toRat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Result</span>.<span class=\"name\">toRat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">e</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Data/Rat/Basic.html#Rat\">ℚ</a></span></span></div></div>","info":{"doc":"Returns the rational number that is the result of `norm_num` evaluation. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.toRat","kind":"def","line":402,"name":"Mathlib.Meta.NormNum.Result.toRat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L402-L408"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.instToMessageDataResult\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">instToMessageDataResult</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Message.html#Lean.ToMessageData\">Lean.ToMessageData</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">x</span>)</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.instToMessageDataResult","kind":"instance","line":393,"name":"Mathlib.Meta.NormNum.instToMessageDataResult","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L393-L400"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.isRat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Result</span>.<span class=\"name\">isRat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">inst</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#DivisionRing\">DivisionRing</a> <span class=\"fn\">«$α»</span></span>)</span> := by assumption)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">q</span> : <a href=\"./Init/Data/Rat/Basic.html#Rat\">ℚ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <span class=\"fn\">Q(<a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">d</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">proof</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsRat\">IsRat</a> <span class=\"fn\">«$x»</span> <span class=\"fn\">«$n»</span> <span class=\"fn\">«$d»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">x</span></span></div></div>","info":{"doc":"The result is `q : ℚ` and `proof : isRat x q`. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.isRat","kind":"def","line":377,"name":"Mathlib.Meta.NormNum.Result.isRat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L377-L390"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.isNNRat'\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Result</span>.<span class=\"name\">isNNRat'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">inst</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#DivisionSemiring\">DivisionSemiring</a> <span class=\"fn\">«$α»</span></span>)</span> := by assumption)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">q</span> : <a href=\"./Init/Data/Rat/Basic.html#Rat\">ℚ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n </span><span class=\"fn\">d</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">proof</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNNRat\">IsNNRat</a> <span class=\"fn\">«$x»</span> <span class=\"fn\">«$n»</span> <span class=\"fn\">«$d»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">x</span></span></div></div>","info":{"doc":"The result is `q : NNRat` and `proof : isNNRat x q`. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.isNNRat'","kind":"def","line":366,"name":"Mathlib.Meta.NormNum.Result.isNNRat'","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L366-L375"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.isInt\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Result</span>.<span class=\"name\">isInt</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">inst</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">«$α»</span></span>)</span> := by assumption)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">z</span> : <span class=\"fn\">Q(<a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">proof</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt\">IsInt</a> <span class=\"fn\">«$x»</span> <span class=\"fn\">«$z»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">x</span></span></div></div>","info":{"doc":"The result is `z : ℤ` and `proof : isNat x z`. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.isInt","kind":"def","line":354,"name":"Mathlib.Meta.NormNum.Result.isInt","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L354-L364"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.isNegNNRat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Result</span>.<span class=\"name\">isNegNNRat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">inst</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#DivisionRing\">DivisionRing</a> <span class=\"fn\">«$α»</span></span>)</span> := by assumption)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">q</span> : <a href=\"./Init/Data/Rat/Basic.html#Rat\">ℚ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n </span><span class=\"fn\">d</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">proof</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsRat\">IsRat</a> <span class=\"fn\">«$x»</span> <span class=\"fn\">(<a href=\"./Init/Data/Int/Basic.html#Int.negOfNat\">Int.negOfNat</a> <span class=\"fn\">«$n»</span>)</span> <span class=\"fn\">«$d»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">x</span></span></div></div>","info":{"doc":"The result is `proof : IsRat x n d`,\nwhere `n` is `.negOfNat lit` with `lit` a raw nat literal,\n`d` is a raw nat literal (not 0 or 1),\n`n` and `d` are coprime, and `q` is the value of `n / d`. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.isNegNNRat","kind":"def","line":344,"name":"Mathlib.Meta.NormNum.Result.isNegNNRat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L344-L350"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.isNNRat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Result</span>.<span class=\"name\">isNNRat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">inst</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#DivisionSemiring\">DivisionSemiring</a> <span class=\"fn\">«$α»</span></span>)</span> := by assumption)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">q</span> : <a href=\"./Init/Data/Rat/Basic.html#Rat\">ℚ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n </span><span class=\"fn\">d</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">proof</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNNRat\">IsNNRat</a> <span class=\"fn\">«$x»</span> <span class=\"fn\">«$n»</span> <span class=\"fn\">«$d»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">x</span></span></div></div>","info":{"doc":"The result is `proof : IsNNRat x n d`,\nwhere `n` a raw nat literal, `d` is a raw nat literal (not 0 or 1),\n`n` and `d` are coprime, and `q` is the value of `n / d`. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.isNNRat","kind":"def","line":337,"name":"Mathlib.Meta.NormNum.Result.isNNRat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L337-L342"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.isNegNat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Result</span>.<span class=\"name\">isNegNat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">inst</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">«$α»</span></span>)</span> := by assumption)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lit</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">proof</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt\">IsInt</a> <span class=\"fn\">«$x»</span> <span class=\"fn\">(<a href=\"./Init/Data/Int/Basic.html#Int.negOfNat\">Int.negOfNat</a> <span class=\"fn\">«$lit»</span>)</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">x</span></span></div></div>","info":{"doc":"The result is `-lit` where `lit` is a raw nat literal\nand `proof : isInt x (.negOfNat lit)`. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.isNegNat","kind":"def","line":331,"name":"Mathlib.Meta.NormNum.Result.isNegNat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L331-L335"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.isNat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Result</span>.<span class=\"name\">isNat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">inst</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Data/Nat/Cast/Defs.html#AddMonoidWithOne\">AddMonoidWithOne</a> <span class=\"fn\">«$α»</span></span>)</span> := by assumption)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lit</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">proof</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">IsNat</a> <span class=\"fn\">«$x»</span> <span class=\"fn\">«$lit»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">x</span></span></div></div>","info":{"doc":"The result is `lit : ℕ` (a raw nat literal) and `proof : isNat x lit`. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.isNat","kind":"def","line":326,"name":"Mathlib.Meta.NormNum.Result.isNat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L326-L329"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.isFalse\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Result</span>.<span class=\"name\">isFalse</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Prop</a>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">proof</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\">«$x»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">q(<span class=\"fn\">«$x»</span>)</span></span></div></div>","info":{"doc":"The result is `proof : ¬x`, where `x` is a (false) proposition. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.isFalse","kind":"def","line":322,"name":"Mathlib.Meta.NormNum.Result.isFalse","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L322-L324"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.isTrue\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Result</span>.<span class=\"name\">isTrue</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Prop</a>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">proof</span> : <span class=\"fn\">Q(<span class=\"fn\">«$x»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">q(<span class=\"fn\">«$x»</span>)</span></span></div></div>","info":{"doc":"The result is `proof : x`, where `x` is a (true) proposition. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.isTrue","kind":"def","line":318,"name":"Mathlib.Meta.NormNum.Result.isTrue","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L318-L320"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.instInhabitedResult\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">instInhabitedResult</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">x</span>)</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.instInhabitedResult","kind":"instance","line":316,"name":"Mathlib.Meta.NormNum.instInhabitedResult","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L316-L316"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Result</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"The result of `norm_num` running on an expression `x` of type `α`. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result","kind":"def","line":313,"name":"Mathlib.Meta.NormNum.Result","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L313-L314"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.instInhabitedResult'\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">instInhabitedResult'</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result'\">Result'</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.instInhabitedResult'","kind":"instance","line":308,"name":"Mathlib.Meta.NormNum.instInhabitedResult'","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L308-L308"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.instInhabitedResult'.default\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">instInhabitedResult'</span>.<span class=\"name\">default</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result'\">Result'</a></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.instInhabitedResult'.default","kind":"def","line":308,"name":"Mathlib.Meta.NormNum.instInhabitedResult'.default","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L308-L308"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result'.isNegNNRat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Result'</span>.<span class=\"name\">isNegNNRat</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">inst</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">q</span> : <a href=\"./Init/Data/Rat/Basic.html#Rat\">ℚ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n </span><span class=\"fn\">d </span><span class=\"fn\">proof</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result'\">Result'</a></div></div>","info":{"doc":"Untyped version of `Result.isNegNNRat`. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result'.isNegNNRat","kind":"ctor","line":306,"name":"Mathlib.Meta.NormNum.Result'.isNegNNRat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L306-L307"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result'.isNNRat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Result'</span>.<span class=\"name\">isNNRat</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">inst</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">q</span> : <a href=\"./Init/Data/Rat/Basic.html#Rat\">ℚ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n </span><span class=\"fn\">d </span><span class=\"fn\">proof</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result'\">Result'</a></div></div>","info":{"doc":"Untyped version of `Result.isNNRat`. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result'.isNNRat","kind":"ctor","line":304,"name":"Mathlib.Meta.NormNum.Result'.isNNRat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L304-L305"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result'.isNegNat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Result'</span>.<span class=\"name\">isNegNat</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">inst </span><span class=\"fn\">lit </span><span class=\"fn\">proof</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result'\">Result'</a></div></div>","info":{"doc":"Untyped version of `Result.isNegNat`. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result'.isNegNat","kind":"ctor","line":302,"name":"Mathlib.Meta.NormNum.Result'.isNegNat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L302-L303"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result'.isNat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Result'</span>.<span class=\"name\">isNat</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">inst </span><span class=\"fn\">lit </span><span class=\"fn\">proof</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result'\">Result'</a></div></div>","info":{"doc":"Untyped version of `Result.isNat`. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result'.isNat","kind":"ctor","line":300,"name":"Mathlib.Meta.NormNum.Result'.isNat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L300-L301"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result'.isBool\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Result'</span>.<span class=\"name\">isBool</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">val</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">proof</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result'\">Result'</a></div></div>","info":{"doc":"Untyped version of `Result.isBool`. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result'.isBool","kind":"ctor","line":298,"name":"Mathlib.Meta.NormNum.Result'.isBool","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L298-L299"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result'\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Result'</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"The result of `norm_num` running on an expression `x` of type `α`.\nUntyped version of `Result`. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result'","kind":"inductive","line":295,"name":"Mathlib.Meta.NormNum.Result'","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L295-L308"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsRat.den_nz\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsRat</span>.<span class=\"name\">den_nz</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#DivisionRing\">DivisionRing</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">d</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsRat\">IsRat</a> <span class=\"fn\">a</span> <span class=\"fn\">n</span> <span class=\"fn\">d</span></span> → <span class=\"fn\">↑<span class=\"fn\">d</span></span> <a href=\"./Init/Core.html#Ne\">≠</a> <span class=\"fn\">0</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsRat.den_nz","kind":"theorem","line":290,"name":"Mathlib.Meta.NormNum.IsRat.den_nz","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L290-L291"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNNRat.den_nz\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsNNRat</span>.<span class=\"name\">den_nz</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#DivisionSemiring\">DivisionSemiring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n </span><span class=\"fn\">d</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNNRat\">IsNNRat</a> <span class=\"fn\">a</span> <span class=\"fn\">n</span> <span class=\"fn\">d</span></span> → <span class=\"fn\">↑<span class=\"fn\">d</span></span> <a href=\"./Init/Core.html#Ne\">≠</a> <span class=\"fn\">0</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNNRat.den_nz","kind":"theorem","line":287,"name":"Mathlib.Meta.NormNum.IsNNRat.den_nz","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L287-L288"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsRat.of_raw\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsRat</span>.<span class=\"name\">of_raw</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#DivisionRing\">DivisionRing</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">d</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">↑<span class=\"fn\">d</span></span> <a href=\"./Init/Core.html#Ne\">≠</a> <span class=\"fn\">0</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsRat\">IsRat</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/NormNum/Result.html#Rat.rawCast\">Rat.rawCast</a> <span class=\"fn\">n</span> <span class=\"fn\">d</span>)</span> <span class=\"fn\">n</span> <span class=\"fn\">d</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsRat.of_raw","kind":"theorem","line":282,"name":"Mathlib.Meta.NormNum.IsRat.of_raw","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L282-L285"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNNRat.of_raw\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsNNRat</span>.<span class=\"name\">of_raw</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#DivisionSemiring\">DivisionSemiring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n </span><span class=\"fn\">d</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">↑<span class=\"fn\">d</span></span> <a href=\"./Init/Core.html#Ne\">≠</a> <span class=\"fn\">0</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNNRat\">IsNNRat</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/NormNum/Result.html#NNRat.rawCast\">NNRat.rawCast</a> <span class=\"fn\">n</span> <span class=\"fn\">d</span>)</span> <span class=\"fn\">n</span> <span class=\"fn\">d</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNNRat.of_raw","kind":"theorem","line":277,"name":"Mathlib.Meta.NormNum.IsNNRat.of_raw","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L277-L280"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNNRat.to_eq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsNNRat</span>.<span class=\"name\">to_eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#DivisionSemiring\">DivisionSemiring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n </span><span class=\"fn\">d</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">n' </span><span class=\"fn\">d'</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNNRat\">IsNNRat</a> <span class=\"fn\">a</span> <span class=\"fn\">n</span> <span class=\"fn\">d</span></span> → <span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">n</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">n'</span> → <span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">d</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">d'</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">n'</span> <a href=\"./Init/Prelude.html#HDiv.hDiv\">/</a> <span class=\"fn\">d'</span></span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNNRat.to_eq","kind":"theorem","line":273,"name":"Mathlib.Meta.NormNum.IsNNRat.to_eq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L273-L275"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsRat.neg_to_eq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsRat</span>.<span class=\"name\">neg_to_eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#DivisionRing\">DivisionRing</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n </span><span class=\"fn\">d</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">n' </span><span class=\"fn\">d'</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsRat\">IsRat</a> <span class=\"fn\">a</span> <span class=\"fn\">(<a href=\"./Init/Data/Int/Basic.html#Int.negOfNat\">Int.negOfNat</a> <span class=\"fn\">n</span>)</span> <span class=\"fn\">d</span></span> → <span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">n</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">n'</span> → <span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">d</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">d'</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Neg.neg\">-</a>(<span class=\"fn\">n'</span> <a href=\"./Init/Prelude.html#HDiv.hDiv\">/</a> <span class=\"fn\">d'</span>)</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsRat.neg_to_eq","kind":"theorem","line":269,"name":"Mathlib.Meta.NormNum.IsRat.neg_to_eq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L269-L271"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsRat.to_raw_eq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsRat</span>.<span class=\"name\">to_raw_eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">d</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#DivisionRing\">DivisionRing</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsRat\">IsRat</a> <span class=\"fn\">a</span> <span class=\"fn\">n</span> <span class=\"fn\">d</span></span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Rat.rawCast\">Rat.rawCast</a> <span class=\"fn\">n</span> <span class=\"fn\">d</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsRat.to_raw_eq","kind":"theorem","line":265,"name":"Mathlib.Meta.NormNum.IsRat.to_raw_eq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L265-L267"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsNNRat</span>.<span class=\"name\">to_raw_eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n </span><span class=\"fn\">d</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#DivisionSemiring\">DivisionSemiring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNNRat\">IsNNRat</a> <span class=\"fn\">a</span> <span class=\"fn\">n</span> <span class=\"fn\">d</span></span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#NNRat.rawCast\">NNRat.rawCast</a> <span class=\"fn\">n</span> <span class=\"fn\">d</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNNRat.to_raw_eq","kind":"theorem","line":261,"name":"Mathlib.Meta.NormNum.IsNNRat.to_raw_eq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L261-L263"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt.to_isRat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsInt</span>.<span class=\"name\">to_isRat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt\">IsInt</a> <span class=\"fn\">a</span> <span class=\"fn\">n</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsRat\">IsRat</a> <span class=\"fn\">a</span> <span class=\"fn\">n</span> <span class=\"fn\">1</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt.to_isRat","kind":"theorem","line":258,"name":"Mathlib.Meta.NormNum.IsInt.to_isRat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L258-L259"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsRat.to_isInt\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsRat</span>.<span class=\"name\">to_isInt</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsRat\">IsRat</a> <span class=\"fn\">a</span> <span class=\"fn\">n</span> <span class=\"fn\">1</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt\">IsInt</a> <span class=\"fn\">a</span> <span class=\"fn\">n</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsRat.to_isInt","kind":"theorem","line":255,"name":"Mathlib.Meta.NormNum.IsRat.to_isInt","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L255-L256"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNNRat.to_isRat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsNNRat</span>.<span class=\"name\">to_isRat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n </span><span class=\"fn\">d</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNNRat\">IsNNRat</a> <span class=\"fn\">a</span> <span class=\"fn\">n</span> <span class=\"fn\">d</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsRat\">IsRat</a> <span class=\"fn\">a</span> <span class=\"fn\">(<a href=\"./Init/Data/Int/Basic.html#Int.ofNat\">Int.ofNat</a> <span class=\"fn\">n</span>)</span> <span class=\"fn\">d</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNNRat.to_isRat","kind":"theorem","line":252,"name":"Mathlib.Meta.NormNum.IsNNRat.to_isRat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L252-L253"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat.to_isNNRat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsNat</span>.<span class=\"name\">to_isNNRat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">IsNat</a> <span class=\"fn\">a</span> <span class=\"fn\">n</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNNRat\">IsNNRat</a> <span class=\"fn\">a</span> <span class=\"fn\">n</span> <span class=\"fn\">1</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat.to_isNNRat","kind":"theorem","line":249,"name":"Mathlib.Meta.NormNum.IsNat.to_isNNRat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L249-L250"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsRat.to_isNNRat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsRat</span>.<span class=\"name\">to_isNNRat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n </span><span class=\"fn\">d</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsRat\">IsRat</a> <span class=\"fn\">a</span> <span class=\"fn\">(<a href=\"./Init/Data/Int/Basic.html#Int.ofNat\">Int.ofNat</a> <span class=\"fn\">n</span>)</span> <span class=\"fn\">d</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNNRat\">IsNNRat</a> <span class=\"fn\">a</span> <span class=\"fn\">n</span> <span class=\"fn\">d</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsRat.to_isNNRat","kind":"theorem","line":246,"name":"Mathlib.Meta.NormNum.IsRat.to_isNNRat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L246-L247"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNNRat.to_isNat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsNNRat</span>.<span class=\"name\">to_isNat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNNRat\">IsNNRat</a> <span class=\"fn\">a</span> <span class=\"fn\">n</span> <span class=\"fn\">1</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">IsNat</a> <span class=\"fn\">a</span> <span class=\"fn\">n</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNNRat.to_isNat","kind":"theorem","line":243,"name":"Mathlib.Meta.NormNum.IsNNRat.to_isNat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L243-L244"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Rat.rawCast\"><span class=\"name\">Rat</span>.<span class=\"name\">rawCast</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#DivisionRing\">DivisionRing</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">d</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">α</span></div></div>","info":{"doc":"A \"raw rat cast\" is an expression of the form:\n\n* `(Nat.rawCast lit : α)` where `lit` is a raw natural number literal\n* `(Int.rawCast (Int.negOfNat lit) : α)` where `lit` is a nonzero raw natural number literal\n* `(NNRat.rawCast n d : α)` where `n` is a raw nat literal, `d` is a raw nat literal, and `d` is not\n  `1` or `0`.\n* `(Rat.rawCast (Int.negOfNat n) d : α)` where `n` is a raw nat literal,\n  `d` is a raw nat literal, `n` is not `0`, and `d` is not `1` or `0`.\n\nThis representation is used by tactics like `ring` to decrease the number of typeclass arguments\nrequired in each use of a number literal at type `α`.\n","docLink":"./Mathlib/Tactic/NormNum/Result.html#Rat.rawCast","kind":"def","line":227,"name":"Rat.rawCast","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L227-L241"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#NNRat.rawCast\"><span class=\"name\">NNRat</span>.<span class=\"name\">rawCast</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#DivisionSemiring\">DivisionSemiring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n </span><span class=\"fn\">d</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">α</span></div></div>","info":{"doc":"A \"raw nnrat cast\" is an expression of the form:\n\n* `(Nat.rawCast lit : α)` where `lit` is a raw natural number literal\n* `(NNRat.rawCast n d : α)` where `n` is a raw nat literal, `d` is a raw nat literal, and `d` is not\n  `1` or `0`.\n\nThis representation is used by tactics like `ring` to decrease the number of typeclass arguments\nrequired in each use of a number literal at type `α`.\n","docLink":"./Mathlib/Tactic/NormNum/Result.html#NNRat.rawCast","kind":"def","line":214,"name":"NNRat.rawCast","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L214-L225"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNNRat.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsNNRat</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">num </span><span class=\"fn\">denom</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">inv</span> : <span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Invertible/Defs.html#Invertible\">Invertible</a> <span class=\"fn\">↑<span class=\"fn\">denom</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">eq</span> : <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">↑<span class=\"fn\">num</span></span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <a href=\"./Mathlib/Algebra/Group/Invertible/Defs.html#Invertible.invOf\">⅟</a><span class=\"fn\">↑<span class=\"fn\">denom</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNNRat\">IsNNRat</a> <span class=\"fn\">a</span> <span class=\"fn\">num</span> <span class=\"fn\">denom</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNNRat.mk","kind":"ctor","line":212,"name":"Mathlib.Meta.NormNum.IsNNRat.mk","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L212-L212"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNNRat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsNNRat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">num </span><span class=\"fn\">denom</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>","info":{"doc":"Assert that an element of a semiring is equal to `num / denom`\n(and `denom` is invertible so that this makes sense).\nWe will usually also have `num` and `denom` coprime,\nalthough this is not part of the definition.\n","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNNRat","kind":"inductive","line":205,"name":"Mathlib.Meta.NormNum.IsNNRat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L205-L212"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsRat.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsRat</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">num</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">denom</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">inv</span> : <span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Invertible/Defs.html#Invertible\">Invertible</a> <span class=\"fn\">↑<span class=\"fn\">denom</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">eq</span> : <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">↑<span class=\"fn\">num</span></span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <a href=\"./Mathlib/Algebra/Group/Invertible/Defs.html#Invertible.invOf\">⅟</a><span class=\"fn\">↑<span class=\"fn\">denom</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsRat\">IsRat</a> <span class=\"fn\">a</span> <span class=\"fn\">num</span> <span class=\"fn\">denom</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsRat.mk","kind":"ctor","line":203,"name":"Mathlib.Meta.NormNum.IsRat.mk","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L203-L203"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsRat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsRat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">num</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">denom</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>","info":{"doc":"Assert that an element of a ring is equal to `num / denom`\n(and `denom` is invertible so that this makes sense).\nWe will usually also have `num` and `denom` coprime,\nalthough this is not part of the definition.\n","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsRat","kind":"inductive","line":196,"name":"Mathlib.Meta.NormNum.IsRat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L196-L203"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt.nonneg_to_eq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsInt</span>.<span class=\"name\">nonneg_to_eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">a'</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt\">IsInt</a> <span class=\"fn\">a</span> <span class=\"fn\">(<a href=\"./Init/Data/Int/Basic.html#Int.ofNat\">Int.ofNat</a> <span class=\"fn\">n</span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">↑<span class=\"fn\">n</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt.nonneg_to_eq","kind":"theorem","line":193,"name":"Mathlib.Meta.NormNum.IsInt.nonneg_to_eq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L193-L194"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt.neg_to_eq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsInt</span>.<span class=\"name\">neg_to_eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">a'</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt\">IsInt</a> <span class=\"fn\">a</span> <span class=\"fn\">(<a href=\"./Init/Data/Int/Basic.html#Int.negOfNat\">Int.negOfNat</a> <span class=\"fn\">n</span>)</span></span> → <span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">n</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\">a'</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt.neg_to_eq","kind":"theorem","line":189,"name":"Mathlib.Meta.NormNum.IsInt.neg_to_eq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L189-L191"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt.of_raw\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsInt</span>.<span class=\"name\">of_raw</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt\">IsInt</a> <span class=\"fn\"><span class=\"fn\">n</span>.<a href=\"./Mathlib/Tactic/NormNum/Result.html#Int.rawCast\">rawCast</a></span> <span class=\"fn\">n</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt.of_raw","kind":"theorem","line":187,"name":"Mathlib.Meta.NormNum.IsInt.of_raw","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L187-L187"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt.to_raw_eq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsInt</span>.<span class=\"name\">to_raw_eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt\">IsInt</a> <span class=\"fn\">a</span> <span class=\"fn\">n</span></span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">n</span>.<a href=\"./Mathlib/Tactic/NormNum/Result.html#Int.rawCast\">rawCast</a></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt.to_raw_eq","kind":"theorem","line":184,"name":"Mathlib.Meta.NormNum.IsInt.to_raw_eq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L184-L185"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat.to_isInt\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsNat</span>.<span class=\"name\">to_isInt</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">IsNat</a> <span class=\"fn\">a</span> <span class=\"fn\">n</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt\">IsInt</a> <span class=\"fn\">a</span> <span class=\"fn\">(<a href=\"./Init/Data/Int/Basic.html#Int.ofNat\">Int.ofNat</a> <span class=\"fn\">n</span>)</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat.to_isInt","kind":"theorem","line":181,"name":"Mathlib.Meta.NormNum.IsNat.to_isInt","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L181-L182"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt.to_isNat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsInt</span>.<span class=\"name\">to_isNat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt\">IsInt</a> <span class=\"fn\">a</span> <span class=\"fn\">(<a href=\"./Init/Data/Int/Basic.html#Int.ofNat\">Int.ofNat</a> <span class=\"fn\">n</span>)</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">IsNat</a> <span class=\"fn\">a</span> <span class=\"fn\">n</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt.to_isNat","kind":"theorem","line":178,"name":"Mathlib.Meta.NormNum.IsInt.to_isNat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L178-L179"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Int.rawCast\"><span class=\"name\">Int</span>.<span class=\"name\">rawCast</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">α</span></div></div>","info":{"doc":"A \"raw int cast\" is an expression of the form:\n\n* `(Nat.rawCast lit : α)` where `lit` is a raw natural number literal\n* `(Int.rawCast (Int.negOfNat lit) : α)` where `lit` is a nonzero raw natural number literal\n\n(That is, we only actually use this function for negative integers.) This representation is used by\ntactics like `ring` to decrease the number of typeclass arguments required in each use of a number\nliteral at type `α`.\n","docLink":"./Mathlib/Tactic/NormNum/Result.html#Int.rawCast","kind":"def","line":166,"name":"Int.rawCast","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L166-L176"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt.out\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsInt</span>.<span class=\"name\">out</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt\">IsInt</a> <span class=\"fn\">a</span> <span class=\"fn\">n</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">↑<span class=\"fn\">n</span></span></div></div>","info":{"doc":"The element is equal to the coercion of the integer. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt.out","kind":"theorem","line":164,"name":"Mathlib.Meta.NormNum.IsInt.out","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L164-L164"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsInt</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">out</span> : <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">↑<span class=\"fn\">n</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt\">IsInt</a> <span class=\"fn\">a</span> <span class=\"fn\">n</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt.mk","kind":"ctor","line":162,"name":"Mathlib.Meta.NormNum.IsInt.mk","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L162-L162"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsInt</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>","info":{"doc":"Assert that an element of a ring is equal to the coercion of some integer. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt","kind":"structure","line":161,"name":"Mathlib.Meta.NormNum.IsInt","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L161-L164"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.isNat.natElim\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">isNat</span>.<span class=\"name\">natElim</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">p</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a> → <a href=\"./foundational_types.html\">Prop</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n </span><span class=\"fn\">n'</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">IsNat</a> <span class=\"fn\">n</span> <span class=\"fn\">n'</span></span> → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">p</span> <span class=\"fn\">n'</span></span> → <span class=\"fn\"><span class=\"fn\">p</span> <span class=\"fn\">n</span></span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.isNat.natElim","kind":"theorem","line":157,"name":"Mathlib.Meta.NormNum.isNat.natElim","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L157-L159"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat.of_raw\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsNat</span>.<span class=\"name\">of_raw</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Data/Nat/Cast/Defs.html#AddMonoidWithOne\">AddMonoidWithOne</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">IsNat</a> <span class=\"fn\"><span class=\"fn\">n</span>.<a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">rawCast</a></span> <span class=\"fn\">n</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat.of_raw","kind":"theorem","line":155,"name":"Mathlib.Meta.NormNum.IsNat.of_raw","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L155-L155"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat.to_raw_eq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsNat</span>.<span class=\"name\">to_raw_eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Data/Nat/Cast/Defs.html#AddMonoidWithOne\">AddMonoidWithOne</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">IsNat</a> <span class=\"fn\">a</span> <span class=\"fn\">n</span></span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">n</span>.<a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">rawCast</a></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat.to_raw_eq","kind":"theorem","line":152,"name":"Mathlib.Meta.NormNum.IsNat.to_raw_eq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L152-L153"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat.to_eq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsNat</span>.<span class=\"name\">to_eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Data/Nat/Cast/Defs.html#AddMonoidWithOne\">AddMonoidWithOne</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">a'</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">IsNat</a> <span class=\"fn\">a</span> <span class=\"fn\">n</span></span> → <span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">n</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat.to_eq","kind":"theorem","line":149,"name":"Mathlib.Meta.NormNum.IsNat.to_eq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L149-L150"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\"><span class=\"name\">Nat</span>.<span class=\"name\">rawCast</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Data/Nat/Cast/Defs.html#AddMonoidWithOne\">AddMonoidWithOne</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">α</span></div></div>","info":{"doc":"A \"raw nat cast\" is an expression of the form `(Nat.rawCast lit : α)` where `lit` is a raw\nnatural number literal. These expressions are used by tactics like `ring` to decrease the number\nof typeclass arguments required in each use of a number literal at type `α`.\n","docLink":"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast","kind":"def","line":142,"name":"Nat.rawCast","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L142-L147"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat.raw_refl\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsNat</span>.<span class=\"name\">raw_refl</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">IsNat</a> <span class=\"fn\">n</span> <span class=\"fn\">n</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat.raw_refl","kind":"theorem","line":140,"name":"Mathlib.Meta.NormNum.IsNat.raw_refl","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L140-L140"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat.out\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsNat</span>.<span class=\"name\">out</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Data/Nat/Cast/Defs.html#AddMonoidWithOne\">AddMonoidWithOne</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">IsNat</a> <span class=\"fn\">a</span> <span class=\"fn\">n</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">↑<span class=\"fn\">n</span></span></div></div>","info":{"doc":"The element is equal to the coercion of the natural number. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat.out","kind":"theorem","line":138,"name":"Mathlib.Meta.NormNum.IsNat.out","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L138-L138"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsNat</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Data/Nat/Cast/Defs.html#AddMonoidWithOne\">AddMonoidWithOne</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">out</span> : <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">↑<span class=\"fn\">n</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">IsNat</a> <span class=\"fn\">a</span> <span class=\"fn\">n</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat.mk","kind":"ctor","line":136,"name":"Mathlib.Meta.NormNum.IsNat.mk","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L136-L136"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsNat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Data/Nat/Cast/Defs.html#AddMonoidWithOne\">AddMonoidWithOne</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>","info":{"doc":"Assert that an element of a semiring is equal to the coercion of some natural number. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat","kind":"structure","line":135,"name":"Mathlib.Meta.NormNum.IsNat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L135-L138"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.mkOfNat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">mkOfNat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">_sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Data/Nat/Cast/Defs.html#AddMonoidWithOne\">AddMonoidWithOne</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lit</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">((<span class=\"fn\">a'</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>) × <span class=\"fn\">Q(<span class=\"fn\">↑<span class=\"fn\">«$lit»</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">«$a'»</span>)</span>)</span></span></div></div>","info":{"doc":"Constructs an `ofNat` application `a'` with the canonical instance, together with a proof that\nthe instance is equal to the result of `Nat.cast` on the given `AddMonoidWithOne` instance.\n\nThis function is performance-critical, as many higher level tactics have to construct numerals.\nSo rather than using typeclass search we hardcode the (relatively small) set of solutions\nto the typeclass problem.\n","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.mkOfNat","kind":"def","line":104,"name":"Mathlib.Meta.NormNum.mkOfNat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L104-L133"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.rawIntLitNatAbs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">rawIntLitNatAbs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <span class=\"fn\">Q(<a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">(<span class=\"fn\">m</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>) × <span class=\"fn\">Q(<span class=\"fn\"><span class=\"fn\">«$n»</span>.<a href=\"./Init/Data/Int/Basic.html#Int.natAbs\">natAbs</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">«$m»</span>)</span></span></div></div>","info":{"doc":"Extract the raw natlit representing the absolute value of a raw integer literal\n(of the type produced by `Mathlib.Meta.NormNum.mkRawIntLit`) along with an equality proof. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.rawIntLitNatAbs","kind":"def","line":92,"name":"Mathlib.Meta.NormNum.rawIntLitNatAbs","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L92-L102"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.mkRawRatLit\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">mkRawRatLit</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">q</span> : <a href=\"./Init/Data/Rat/Basic.html#Rat\">ℚ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">Q(<a href=\"./Init/Data/Rat/Basic.html#Rat\">ℚ</a>)</span></div></div>","info":{"doc":"Represent an integer as a \"raw\" typed expression.\n\nThis `.lit (.natVal n)` internally to represent a natural number,\nrather than the preferred `OfNat.ofNat` form.\nWe use this internally to avoid unnecessary typeclass searches.\n","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.mkRawRatLit","kind":"def","line":80,"name":"Mathlib.Meta.NormNum.mkRawRatLit","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L80-L90"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.mkRawIntLit\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">mkRawIntLit</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">Q(<a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></div></div>","info":{"doc":"Represent an integer as a \"raw\" typed expression.\n\nThis uses `.lit (.natVal n)` internally to represent a natural number,\nrather than the preferred `OfNat.ofNat` form.\nWe use this internally to avoid unnecessary typeclass searches.\n\nThis function is the inverse of `Expr.intLit!`.\n","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.mkRawIntLit","kind":"def","line":67,"name":"Mathlib.Meta.NormNum.mkRawIntLit","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L67-L78"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.inferRing\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">inferRing</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">«$α»</span></span>)</span></span></div></div>","info":{"doc":"Helper function to synthesize a typed `Ring α` expression. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.inferRing","kind":"def","line":63,"name":"Mathlib.Meta.NormNum.inferRing","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L63-L65"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.inferSemiring\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">inferSemiring</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">«$α»</span></span>)</span></span></div></div>","info":{"doc":"Helper function to synthesize a typed `Semiring α` expression. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.inferSemiring","kind":"def","line":59,"name":"Mathlib.Meta.NormNum.inferSemiring","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L59-L61"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.inferAddMonoidWithOne\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">inferAddMonoidWithOne</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Data/Nat/Cast/Defs.html#AddMonoidWithOne\">AddMonoidWithOne</a> <span class=\"fn\">«$α»</span></span>)</span></span></div></div>","info":{"doc":"Helper function to synthesize a typed `AddMonoidWithOne α` expression. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.inferAddMonoidWithOne","kind":"def","line":54,"name":"Mathlib.Meta.NormNum.inferAddMonoidWithOne","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L54-L57"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.instAtLeastTwo\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">instAtLeastTwo</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">(<span class=\"fn\">n</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">2</span>).<a href=\"./Mathlib/Data/Nat/Init.html#Nat.AtLeastTwo\">AtLeastTwo</a></span></div></div>","info":{"doc":"A shortcut (non)instance for `Nat.AtLeastTwo (n + 2)` to shrink generated proofs. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.instAtLeastTwo","kind":"theorem","line":51,"name":"Mathlib.Meta.NormNum.instAtLeastTwo","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L51-L52"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.instAddMonoidWithOne\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">instAddMonoidWithOne</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/Nat/Cast/Defs.html#AddMonoidWithOne\">AddMonoidWithOne</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"A shortcut (non)instance for `AddMonoidWithOne α` from `Ring α` to shrink generated proofs. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.instAddMonoidWithOne","kind":"def","line":48,"name":"Mathlib.Meta.NormNum.instAddMonoidWithOne","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L48-L49"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.instAddMonoidWithOne'\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">instAddMonoidWithOne'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/Nat/Cast/Defs.html#AddMonoidWithOne\">AddMonoidWithOne</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"A shortcut (non)instance for `AddMonoidWithOne α`\nfrom `Semiring α` to shrink generated proofs. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.instAddMonoidWithOne'","kind":"def","line":44,"name":"Mathlib.Meta.NormNum.instAddMonoidWithOne'","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L44-L46"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.instAddMonoidWithOneNat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">instAddMonoidWithOneNat</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/Nat/Cast/Defs.html#AddMonoidWithOne\">AddMonoidWithOne</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span></div></div>","info":{"doc":"A shortcut (non)instance for `AddMonoidWithOne ℕ` to shrink generated proofs. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.instAddMonoidWithOneNat","kind":"def","line":41,"name":"Mathlib.Meta.NormNum.instAddMonoidWithOneNat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Result.lean#L41-L42"}}],"imports":["Init","Mathlib.Algebra.Field.Defs","Mathlib.Algebra.GroupWithZero.Invertible","Mathlib.Data.Sigma.Basic","Mathlib.Algebra.Ring.Nat","Mathlib.Data.Int.Cast.Basic","Qq.MetaM"],"instances":[{"className":"Inhabited","name":"Mathlib.Meta.NormNum.instInhabitedResult'","typeNames":["Mathlib.Meta.NormNum.Result'"]},{"className":"Inhabited","name":"Mathlib.Meta.NormNum.instInhabitedResult","typeNames":["Mathlib.Meta.NormNum.Result"]},{"className":"Lean.ToMessageData","name":"Mathlib.Meta.NormNum.instToMessageDataResult","typeNames":["Mathlib.Meta.NormNum.Result"]}],"name":"Mathlib.Tactic.NormNum.Result"}