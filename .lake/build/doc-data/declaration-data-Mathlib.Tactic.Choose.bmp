{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.tacticChoose!___Using_\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Choose</span>.<span class=\"name\">tacticChoose!___Using_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"* `choose a b h h' using hyp` takes a hypothesis `hyp` of the form\n  `∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b ∧ Q x y a b`\n  for some `P Q : X → Y → A → B → Prop` and outputs\n  into context a function `a : X → Y → A`, `b : X → Y → B` and two assumptions:\n  `h : ∀ (x : X) (y : Y), P x y (a x y) (b x y)` and\n  `h' : ∀ (x : X) (y : Y), Q x y (a x y) (b x y)`. It also works with dependent versions.\n\n* `choose! a b h h' using hyp` does the same, except that it will remove dependency of\n  the functions on propositional arguments if possible. For example if `Y` is a proposition\n  and `A` and `B` are nonempty in the above example then we will instead get\n  `a : X → A`, `b : X → B`, and the assumptions\n  `h : ∀ (x : X) (y : Y), P x y (a x) (b x)` and\n  `h' : ∀ (x : X) (y : Y), Q x y (a x) (b x)`.\n\nThe `using hyp` part can be omitted,\nwhich will effectively cause `choose` to start with an `intro hyp`.\n\nExamples:\n\n```\nexample (h : ∀ n m : ℕ, ∃ i j, m = n + i ∨ m + j = n) : True := by\n  choose i j h using h\n  guard_hyp i : ℕ → ℕ → ℕ\n  guard_hyp j : ℕ → ℕ → ℕ\n  guard_hyp h : ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n\n  trivial\n```\n\n```\nexample (h : ∀ i : ℕ, i < 7 → ∃ j, i < j ∧ j < i+i) : True := by\n  choose! f h h' using h\n  guard_hyp f : ℕ → ℕ\n  guard_hyp h : ∀ (i : ℕ), i < 7 → i < f i\n  guard_hyp h' : ∀ (i : ℕ), i < 7 → f i < i + i\n  trivial\n```\n","docLink":"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.tacticChoose!___Using_","kind":"def","line":222,"name":"Mathlib.Tactic.Choose.tacticChoose!___Using_","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Choose.lean#L222-L223"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.choose\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Choose</span>.<span class=\"name\">choose</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"* `choose a b h h' using hyp` takes a hypothesis `hyp` of the form\n  `∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b ∧ Q x y a b`\n  for some `P Q : X → Y → A → B → Prop` and outputs\n  into context a function `a : X → Y → A`, `b : X → Y → B` and two assumptions:\n  `h : ∀ (x : X) (y : Y), P x y (a x y) (b x y)` and\n  `h' : ∀ (x : X) (y : Y), Q x y (a x y) (b x y)`. It also works with dependent versions.\n\n* `choose! a b h h' using hyp` does the same, except that it will remove dependency of\n  the functions on propositional arguments if possible. For example if `Y` is a proposition\n  and `A` and `B` are nonempty in the above example then we will instead get\n  `a : X → A`, `b : X → B`, and the assumptions\n  `h : ∀ (x : X) (y : Y), P x y (a x) (b x)` and\n  `h' : ∀ (x : X) (y : Y), Q x y (a x) (b x)`.\n\nThe `using hyp` part can be omitted,\nwhich will effectively cause `choose` to start with an `intro hyp`.\n\nExamples:\n\n```\nexample (h : ∀ n m : ℕ, ∃ i j, m = n + i ∨ m + j = n) : True := by\n  choose i j h using h\n  guard_hyp i : ℕ → ℕ → ℕ\n  guard_hyp j : ℕ → ℕ → ℕ\n  guard_hyp h : ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n\n  trivial\n```\n\n```\nexample (h : ∀ i : ℕ, i < 7 → ∃ j, i < j ∧ j < i+i) : True := by\n  choose! f h h' using h\n  guard_hyp f : ℕ → ℕ\n  guard_hyp h : ∀ (i : ℕ), i < 7 → i < f i\n  guard_hyp h' : ∀ (i : ℕ), i < 7 → f i < i + i\n  trivial\n```\n","docLink":"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.choose","kind":"def","line":177,"name":"Mathlib.Tactic.Choose.choose","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Choose.lean#L177-L215"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.elabChoose\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Choose</span>.<span class=\"name\">elabChoose</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">nondep</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> (<a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`Lean.binderIdent</span>)</span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ElimStatus\">ElimStatus</a> → <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span></span></span></span></div></div>","info":{"doc":"A loop around `choose1`. The main entry point for the `choose` tactic. ","docLink":"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.elabChoose","kind":"def","line":156,"name":"Mathlib.Tactic.Choose.elabChoose","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Choose.lean#L156-L175"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.choose1WithInfo\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Choose</span>.<span class=\"name\">choose1WithInfo</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">g</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">nondep</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">data</span> : <a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`Lean.binderIdent</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> (<a href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ElimStatus\">ElimStatus</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></div></div>","info":{"doc":"A wrapper around `choose1` that parses identifiers and adds variable info to new variables. ","docLink":"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.choose1WithInfo","kind":"def","line":148,"name":"Mathlib.Tactic.Choose.choose1WithInfo","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Choose.lean#L148-L154"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.choose1\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Choose</span>.<span class=\"name\">choose1</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">g</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">nondep</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">data</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> (<a href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ElimStatus\">ElimStatus</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></div></div>","info":{"doc":"Changes `(h : ∀ xs, ∃ a:α, p a) ⊢ g` to `(d : ∀ xs, a) ⊢ (s : ∀ xs, p (d xs)) → g` and\n`(h : ∀ xs, p xs ∧ q xs) ⊢ g` to `(d : ∀ xs, p xs) ⊢ (s : ∀ xs, q xs) → g`.\n`choose1` returns a tuple of\n\n- the error result (see `ElimStatus`)\n- the data new free variable that was \"chosen\"\n- the new goal (which contains the spec of the data as domain of an arrow type)\n\nIf `nondep` is true and `α` is inhabited, then it will remove the dependency of `d` on\nall propositional assumptions in `xs`. For example if `ys` are propositions then\n`(h : ∀ xs ys, ∃ a:α, p a) ⊢ g` becomes `(d : ∀ xs, a) (s : ∀ xs ys, p (d xs)) ⊢ g`. ","docLink":"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.choose1","kind":"def","line":71,"name":"Mathlib.Tactic.Choose.choose1","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Choose.lean#L71-L146"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.mkFreshNameFrom\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Choose</span>.<span class=\"name\">mkFreshNameFrom</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">orig </span><span class=\"fn\">base</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">Lean.CoreM</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span></div></div>","info":{"doc":"`mkFreshNameFrom orig base` returns `mkFreshUserName base` if ``orig = `_``\nand `orig` otherwise. ","docLink":"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.mkFreshNameFrom","kind":"def","line":66,"name":"Mathlib.Tactic.Choose.mkFreshNameFrom","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Choose.lean#L66-L69"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ElimStatus.merge\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Choose</span>.<span class=\"name\">ElimStatus</span>.<span class=\"name\">merge</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ElimStatus\">ElimStatus</a> → <a href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ElimStatus\">ElimStatus</a> → <a href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ElimStatus\">ElimStatus</a></span></div></div>","info":{"doc":"Combine two statuses, keeping a success from either side\nor merging the failures. ","docLink":"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ElimStatus.merge","kind":"def","line":59,"name":"Mathlib.Tactic.Choose.ElimStatus.merge","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Choose.lean#L59-L64"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ElimStatus.failure\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Choose</span>.<span class=\"name\">ElimStatus</span>.<span class=\"name\">failure</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ts</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ElimStatus\">ElimStatus</a></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ElimStatus.failure","kind":"ctor","line":57,"name":"Mathlib.Tactic.Choose.ElimStatus.failure","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Choose.lean#L57-L57"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ElimStatus.success\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Choose</span>.<span class=\"name\">ElimStatus</span>.<span class=\"name\">success</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ElimStatus\">ElimStatus</a></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ElimStatus.success","kind":"ctor","line":56,"name":"Mathlib.Tactic.Choose.ElimStatus.success","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Choose.lean#L56-L56"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ElimStatus\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Choose</span>.<span class=\"name\">ElimStatus</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"Results of searching for nonempty instances,\nto eliminate dependencies on propositions (`choose!`).\n`success` means we found at least one instance;\n`failure ts` means we didn't find instances for any `t ∈ ts`.\n(`failure []` means we didn't look for instances at all.)\n\nRationale:\n`choose!` means we are expected to succeed at least once\nin eliminating dependencies on propositions.\n","docLink":"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ElimStatus","kind":"inductive","line":45,"name":"Mathlib.Tactic.Choose.ElimStatus","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Choose.lean#L45-L57"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.mk_sometimes\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Choose</span>.<span class=\"name\">mk_sometimes</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α </span><span class=\"fn\">nonemp </span><span class=\"fn\">p</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> → <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></span></div></div>","info":{"doc":"Given `α : Sort u`, `nonemp : Nonempty α`, `p : α → Prop`, a context of free variables\n`ctx`, and a pair of an element `val : α` and `spec : p val`,\n`mk_sometimes u α nonemp p ctx (val, spec)` produces another pair `val', spec'`\nsuch that `val'` does not have any free variables from elements of `ctx` whose types are\npropositions. This is done by applying `Function.sometimes` to abstract over all the propositional\narguments. ","docLink":"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.mk_sometimes","kind":"def","line":25,"name":"Mathlib.Tactic.Choose.mk_sometimes","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Choose.lean#L25-L43"}}],"imports":["Init","Mathlib.Util.Tactic","Mathlib.Logic.Function.Basic"],"instances":[],"name":"Mathlib.Tactic.Choose"}