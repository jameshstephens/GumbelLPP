{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.tacticOrder_\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Order</span>.<span class=\"name\">tacticOrder_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"A finishing tactic for solving goals in arbitrary `Preorder`, `PartialOrder`,\nor `LinearOrder`. Supports `⊤`, `⊥`, and lattice operations. ","docLink":"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.tacticOrder_","kind":"def","line":302,"name":"Mathlib.Tactic.Order.tacticOrder_","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Order.lean#L302-L306"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.order_core\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Order</span>.<span class=\"name\">order_core</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`order_core` is the part of the `order` tactic that tries to find a contradiction. ","docLink":"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.order_core","kind":"def","line":290,"name":"Mathlib.Tactic.Order.order_core","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Order.lean#L290-L291"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.orderArgs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Order</span>.<span class=\"name\">orderArgs</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"Args for the `order` tactic. ","docLink":"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.orderArgs","kind":"def","line":287,"name":"Mathlib.Tactic.Order.orderArgs","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Order.lean#L287-L288"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.orderCore\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Order</span>.<span class=\"name\">orderCore</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">only?</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hyps</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">negGoal</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">g</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Core of the `order` tactic. ","docLink":"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.orderCore","kind":"def","line":283,"name":"Mathlib.Tactic.Order.orderCore","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Order.lean#L283-L285"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.orderCoreImp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Order</span>.<span class=\"name\">orderCoreImp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">only?</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hyps</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">negGoal</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">g</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Implementation of `orderCore` in `AtomM`. ","docLink":"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.orderCoreImp","kind":"def","line":233,"name":"Mathlib.Tactic.Order.orderCoreImp","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Order.lean#L233-L281"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.instOrdProdNatExpr_mathlib\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Order</span>.<span class=\"name\">instOrdProdNatExpr_mathlib</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Ord/Basic.html#Ord\">Ord</a> (<a href=\"./Init/Prelude.html#Nat\">ℕ</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></div></div>","info":{"doc":"Necessary for tracing below. ","docLink":"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.instOrdProdNatExpr_mathlib","kind":"def","line":229,"name":"Mathlib.Tactic.Order.instOrdProdNatExpr_mathlib","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Order.lean#L229-L231"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.updateGraphWithNltInfSup\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Order</span>.<span class=\"name\">updateGraphWithNltInfSup</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">g</span> : <a href=\"./Mathlib/Tactic/Order/Graph/Basic.html#Mathlib.Tactic.Order.Graph\">Graph</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">facts</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Mathlib/Tactic/Order/CollectFacts.html#Mathlib.Tactic.Order.AtomicFact\">AtomicFact</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> <a href=\"./Mathlib/Tactic/Order/Graph/Basic.html#Mathlib.Tactic.Order.Graph\">Graph</a></span></div></div>","info":{"doc":"Adds edges to the `≤`-graph using two types of facts:\n1. Each fact `¬ (x < y)` allows to add the edge `(x, y)` when `y` is reachable from `x` in the\ngraph.\n2. Each fact `x ⊔ y = z` allows to add the edge `(z, s)` when `s` is reachable from both `x`\nand `y`.\n\nWe repeat the process until no more edges can be added. ","docLink":"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.updateGraphWithNltInfSup","kind":"def","line":184,"name":"Mathlib.Tactic.Order.updateGraphWithNltInfSup","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Order.lean#L184-L227"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.findContradictionWithNle\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Order</span>.<span class=\"name\">findContradictionWithNle</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">g</span> : <a href=\"./Mathlib/Tactic/Order/Graph/Basic.html#Mathlib.Tactic.Order.Graph\">Graph</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">facts</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Mathlib/Tactic/Order/CollectFacts.html#Mathlib.Tactic.Order.AtomicFact\">AtomicFact</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>","info":{"doc":"Using the `≤`-graph `g`, find a contradiction with some `≰`-fact. ","docLink":"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.findContradictionWithNle","kind":"def","line":175,"name":"Mathlib.Tactic.Order.findContradictionWithNle","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Order.lean#L175-L182"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.findContradictionWithNe\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Order</span>.<span class=\"name\">findContradictionWithNe</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">graph</span> : <a href=\"./Mathlib/Tactic/Order/Graph/Basic.html#Mathlib.Tactic.Order.Graph\">Graph</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">facts</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Mathlib/Tactic/Order/CollectFacts.html#Mathlib.Tactic.Order.AtomicFact\">AtomicFact</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>","info":{"doc":"Finds a contradictory `≠`-fact whose `.lhs` and `.rhs` belong to the same strongly connected\ncomponent in the `≤`-graph, implying they must be equal, and then uses it to derive `False`. ","docLink":"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.findContradictionWithNe","kind":"def","line":155,"name":"Mathlib.Tactic.Order.findContradictionWithNe","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Order.lean#L155-L173"}}],"imports":["Init","Mathlib.Tactic.ByContra","Mathlib.Tactic.Order.CollectFacts","Mathlib.Tactic.Order.Preprocessing","Mathlib.Tactic.Order.ToInt","Mathlib.Tactic.Order.Graph.Basic","Mathlib.Tactic.Order.Graph.Tarjan","Mathlib.Util.ElabWithoutMVars"],"instances":[],"name":"Mathlib.Tactic.Order"}