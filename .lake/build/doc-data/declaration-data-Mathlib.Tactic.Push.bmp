{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.elabPushTree\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">elabPushTree</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Elab/Command.html#Lean.Elab.Command.CommandElab\">Lean.Elab.Command.CommandElab</a></div></div>","info":{"doc":"`#push_discr_tree X` shows the discrimination tree of all lemmas used by `push X`.\nThis can be helpful when you are constructing a set of `push` lemmas for the constant `X`.\n","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.elabPushTree","kind":"def","line":359,"name":"Mathlib.Tactic.Push.elabPushTree","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Push.lean#L359-L376"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pushTree\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">pushTree</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`#push_discr_tree X` shows the discrimination tree of all lemmas used by `push X`.\nThis can be helpful when you are constructing a set of `push` lemmas for the constant `X`.\n","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pushTree","kind":"def","line":353,"name":"Mathlib.Tactic.Push.pushTree","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Push.lean#L353-L357"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pullCommand\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">pullCommand</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"The syntax is `#pull head e`, where `head` is a constant and `e` is an expression,\nwhich will print the `pull head` form of `e`.\n\n`#pull` understands local variables, so you can use them to introduce parameters.\n","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pullCommand","kind":"def","line":345,"name":"Mathlib.Tactic.Push.pullCommand","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Push.lean#L345-L347"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.convPull____\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">convPull____</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`pull` is the inverse tactic to `push`.\nIt pulls the given constant towards the head of the expression. For example\n- `pull _ ∈ _` rewrites `x ∈ y ∨ ¬ x ∈ z` into `x ∈ y ∪ zᶜ`.\n- `pull (disch := positivity) Real.log` rewrites `log a + 2 * log b` into `log (a * b ^ 2)`.\n- `pull fun _ ↦ _` rewrites `f ^ 2 + 5` into `fun x => f x ^ 2 + 5` where `f` is a function.\n\nA lemma is considered a `pull` lemma if its reverse direction is a `push` lemma\nthat actually moves the given constant away from the head. For example\n- `not_or : ¬ (p ∨ q) ↔ ¬ p ∧ ¬ q` is a `pull` lemma, but `not_not : ¬ ¬ p ↔ p` is not.\n- `log_mul : log (x * y) = log x + log y` is a `pull` lemma, but `log_abs : log |x| = log x` is not.\n- `Pi.mul_def : f * g = fun (i : ι) => f i * g i` and `Pi.one_def : 1 = fun (x : ι) => 1` are both\n  `pull` lemmas for `fun`, because every `push fun _ ↦ _` lemma is also considered a `pull` lemma.\n\nTODO: define a `@[pull]` attribute for tagging `pull` lemmas that are not `push` lemmas.\n","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.convPull____","kind":"def","line":333,"name":"Mathlib.Tactic.Push.convPull____","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Push.lean#L333-L337"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pushNegCommand\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">pushNegCommand</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"The syntax is `#push_neg e`, where `e` is an expression,\nwhich will print the `push_neg` form of `e`.\n\n`#push_neg` understands local variables, so you can use them to introduce parameters.\n","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pushNegCommand","kind":"def","line":330,"name":"Mathlib.Tactic.Push.pushNegCommand","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Push.lean#L330-L331"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pushCommand\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">pushCommand</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"The syntax is `#push head e`, where `head` is a constant and `e` is an expression,\nwhich will print the `push head` form of `e`.\n\n`#push` understands local variables, so you can use them to introduce parameters.\n","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pushCommand","kind":"def","line":320,"name":"Mathlib.Tactic.Push.pushCommand","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Push.lean#L320-L322"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.convPush_neg_\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">convPush_neg_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"Push negations into the conclusion or a hypothesis.\nFor instance, a hypothesis `h : ¬ ∀ x, ∃ y, x ≤ y` will be transformed by `push_neg at h` into\n`h : ∃ x, ∀ y, y < x`. Binder names are preserved.\n\n`push_neg` is a special case of the more general `push` tactic, namely `push Not`.\nThe `push` tactic can be extended using the `@[push]` attribute. `push` has special-casing\nbuilt in for `push Not`, so that it can preserve binder names, and so that `¬ (p ∧ q)` can be\ntransformed to either `p → ¬ q` (default) or `¬ p ∨ ¬ q` (`push_neg +distrib`).\n\nTactics that introduce a negation usually have a version that automatically calls `push_neg` on\nthat negation. These include `by_cases!`, `contrapose!` and `by_contra!`.\n\nAnother example: given a hypothesis\n```lean\nh : ¬ ∀ ε > 0, ∃ δ > 0, ∀ x, |x - x₀| ≤ δ → |f x - y₀| ≤ ε\n```\nwriting `push_neg at h` will turn `h` into\n```lean\nh : ∃ ε > 0, ∀ δ > 0, ∃ x, |x - x₀| ≤ δ ∧ ε < |f x - y₀|\n```\nNote that binder names are preserved by this tactic, contrary to what would happen with `simp`\nusing the relevant lemmas. One can use this tactic at the goal using `push_neg`,\nat every hypothesis and the goal using `push_neg at *` or at selected hypotheses and the goal\nusing say `push_neg at h h' ⊢`, as usual.\n","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.convPush_neg_","kind":"def","line":312,"name":"Mathlib.Tactic.Push.convPush_neg_","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Push.lean#L312-L312"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.convPush_____\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">convPush_____</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`push` pushes the given constant away from the head of the expression. For example\n- `push _ ∈ _` rewrites `x ∈ {y} ∪ zᶜ` into `x = y ∨ ¬ x ∈ z`.\n- `push (disch := positivity) Real.log` rewrites `log (a * b ^ 2)` into `log a + 2 * log b`.\n- `push ¬ _` is the same as `push_neg` or `push Not`, and it rewrites\n  `¬ ∀ ε > 0, ∃ δ > 0, δ < ε` into `∃ ε > 0, ∀ δ > 0, ε ≤ δ`.\n\nIn addition to constants, `push` can be used to push `fun` and `∀` binders:\n- `push fun _ ↦ _` rewrites `fun x => f x ^ 2 + 5` into `f ^ 2 + 5`\n- `push ∀ _, _` rewrites `∀ a, p a ∧ q a` into `(∀ a, p a) ∧ (∀ a, q a)`.\n\nThe `push` tactic can be extended using the `@[push]` attribute.\n\nTo instead move a constant closer to the head of the expression, use the `pull` tactic.\n\nTo push a constant at a hypothesis, use the `push ... at h` or `push ... at *` syntax.\n","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.convPush_____","kind":"def","line":300,"name":"Mathlib.Tactic.Push.convPush_____","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Push.lean#L300-L309"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#pullFun\"><span class=\"name\">pullFun</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Simproc\">Lean.Meta.Simp.Simproc</a></div></div>","info":{"doc":"A simproc variant of `pull fun _ ↦ _`, to be used as `simp [pullFun]`. ","docLink":"./Mathlib/Tactic/Push.html#pullFun","kind":"def","line":295,"name":"pullFun","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Push.lean#L295-L296"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#pushFun\"><span class=\"name\">pushFun</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Simproc\">Lean.Meta.Simp.Simproc</a></div></div>","info":{"doc":"A simproc variant of `push fun _ ↦ _`, to be used as `simp [↓pushFun]`. ","docLink":"./Mathlib/Tactic/Push.html#pushFun","kind":"def","line":292,"name":"pushFun","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Push.lean#L292-L293"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pull\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">pull</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`pull` is the inverse tactic to `push`.\nIt pulls the given constant towards the head of the expression. For example\n- `pull _ ∈ _` rewrites `x ∈ y ∨ ¬ x ∈ z` into `x ∈ y ∪ zᶜ`.\n- `pull (disch := positivity) Real.log` rewrites `log a + 2 * log b` into `log (a * b ^ 2)`.\n- `pull fun _ ↦ _` rewrites `f ^ 2 + 5` into `fun x => f x ^ 2 + 5` where `f` is a function.\n\nA lemma is considered a `pull` lemma if its reverse direction is a `push` lemma\nthat actually moves the given constant away from the head. For example\n- `not_or : ¬ (p ∨ q) ↔ ¬ p ∧ ¬ q` is a `pull` lemma, but `not_not : ¬ ¬ p ↔ p` is not.\n- `log_mul : log (x * y) = log x + log y` is a `pull` lemma, but `log_abs : log |x| = log x` is not.\n- `Pi.mul_def : f * g = fun (i : ι) => f i * g i` and `Pi.one_def : 1 = fun (x : ι) => 1` are both\n  `pull` lemmas for `fun`, because every `push fun _ ↦ _` lemma is also considered a `pull` lemma.\n\nTODO: define a `@[pull]` attribute for tagging `pull` lemmas that are not `push` lemmas.\n","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pull","kind":"def","line":269,"name":"Mathlib.Tactic.Push.pull","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Push.lean#L269-L290"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.push_neg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">push_neg</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"Push negations into the conclusion or a hypothesis.\nFor instance, a hypothesis `h : ¬ ∀ x, ∃ y, x ≤ y` will be transformed by `push_neg at h` into\n`h : ∃ x, ∀ y, y < x`. Binder names are preserved.\n\n`push_neg` is a special case of the more general `push` tactic, namely `push Not`.\nThe `push` tactic can be extended using the `@[push]` attribute. `push` has special-casing\nbuilt in for `push Not`, so that it can preserve binder names, and so that `¬ (p ∧ q)` can be\ntransformed to either `p → ¬ q` (default) or `¬ p ∨ ¬ q` (`push_neg +distrib`).\n\nTactics that introduce a negation usually have a version that automatically calls `push_neg` on\nthat negation. These include `by_cases!`, `contrapose!` and `by_contra!`.\n\nAnother example: given a hypothesis\n```lean\nh : ¬ ∀ ε > 0, ∃ δ > 0, ∀ x, |x - x₀| ≤ δ → |f x - y₀| ≤ ε\n```\nwriting `push_neg at h` will turn `h` into\n```lean\nh : ∃ ε > 0, ∀ δ > 0, ∃ x, |x - x₀| ≤ δ ∧ ε < |f x - y₀|\n```\nNote that binder names are preserved by this tactic, contrary to what would happen with `simp`\nusing the relevant lemmas. One can use this tactic at the goal using `push_neg`,\nat every hypothesis and the goal using `push_neg at *` or at selected hypotheses and the goal\nusing say `push_neg at h h' ⊢`, as usual.\n","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.push_neg","kind":"def","line":239,"name":"Mathlib.Tactic.Push.push_neg","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Push.lean#L239-L267"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pushStx\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">pushStx</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`push` pushes the given constant away from the head of the expression. For example\n- `push _ ∈ _` rewrites `x ∈ {y} ∪ zᶜ` into `x = y ∨ ¬ x ∈ z`.\n- `push (disch := positivity) Real.log` rewrites `log (a * b ^ 2)` into `log a + 2 * log b`.\n- `push ¬ _` is the same as `push_neg` or `push Not`, and it rewrites\n  `¬ ∀ ε > 0, ∃ δ > 0, δ < ε` into `∃ ε > 0, ∀ δ > 0, ε ≤ δ`.\n\nIn addition to constants, `push` can be used to push `fun` and `∀` binders:\n- `push fun _ ↦ _` rewrites `fun x => f x ^ 2 + 5` into `f ^ 2 + 5`\n- `push ∀ _, _` rewrites `∀ a, p a ∧ q a` into `(∀ a, p a) ∧ (∀ a, q a)`.\n\nThe `push` tactic can be extended using the `@[push]` attribute.\n\nTo instead move a constant closer to the head of the expression, use the `pull` tactic.\n\nTo push a constant at a hypothesis, use the `push ... at h` or `push ... at *` syntax.\n","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pushStx","kind":"def","line":216,"name":"Mathlib.Tactic.Push.pushStx","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Push.lean#L216-L237"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.push\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">push</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">cfg</span> : <a href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.Config\">Config</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">disch?</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Meta/Tactic/Simp/Rewrite.html#Lean.Meta.Simp.Discharge\">Lean.Meta.Simp.Discharge</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">head</span> : <a href=\"./Mathlib/Tactic/Push/Attr.html#Mathlib.Tactic.Push.Head\">Head</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">loc</span> : <a href=\"./Lean/Elab/Tactic/Location.html#Lean.Elab.Tactic.Location\">Lean.Elab.Tactic.Location</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">failIfUnchanged</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Run the `push` tactic. ","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.push","kind":"def","line":210,"name":"Mathlib.Tactic.Push.push","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Push.lean#L210-L214"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.elabDischarger\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">elabDischarger</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">stx</span> : <a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`Lean.Parser.Tactic.discharger</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Lean/Meta/Tactic/Simp/Rewrite.html#Lean.Meta.Simp.Discharge\">Lean.Meta.Simp.Discharge</a></span></div></div>","info":{"doc":"Elaborate the `(disch := ...)` syntax for a `simp`-like tactic. ","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.elabDischarger","kind":"def","line":206,"name":"Mathlib.Tactic.Push.elabDischarger","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Push.lean#L206-L208"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.elabHead\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">elabHead</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">stx</span> : <a href=\"./Init/Meta/Defs.html#Lean.Syntax.Term\">Lean.Term</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <a href=\"./Mathlib/Tactic/Push/Attr.html#Mathlib.Tactic.Push.Head\">Head</a></span></div></div>","info":{"doc":"Elaborator for the argument passed to `push`. It accepts a constant, or a function ","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.elabHead","kind":"def","line":188,"name":"Mathlib.Tactic.Push.elabHead","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Push.lean#L188-L202"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.resolvePushId?\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">resolvePushId?</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">stx</span> : <a href=\"./Init/Meta/Defs.html#Lean.Syntax.Term\">Lean.Term</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>","info":{"doc":"`resolvePushId?` is a version of `resolveId?` that also supports notations like `_ ∈ _`,\n`∃ x, _` and `∑ x, _`. ","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.resolvePushId?","kind":"def","line":166,"name":"Mathlib.Tactic.Push.resolvePushId?","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Push.lean#L166-L186"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.isUnderscore\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">isUnderscore</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Meta/Defs.html#Lean.Syntax.Term\">Lean.Term</a> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"Return `true` if `stx` is an underscore, i.e. `_` or `fun $_ => _`/`fun $_ ↦ _`. ","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.isUnderscore","kind":"def","line":161,"name":"Mathlib.Tactic.Push.isUnderscore","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Push.lean#L161-L164"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pullCore\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">pullCore</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">head</span> : <a href=\"./Mathlib/Tactic/Push/Attr.html#Mathlib.Tactic.Push.Head\">Head</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">tgt</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">disch?</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Meta/Tactic/Simp/Rewrite.html#Lean.Meta.Simp.Discharge\">Lean.Meta.Simp.Discharge</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span></div></div>","info":{"doc":"Common entry point to the implementation of `pull`. ","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pullCore","kind":"def","line":148,"name":"Mathlib.Tactic.Push.pullCore","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Push.lean#L148-L156"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pullStep\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">pullStep</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">head</span> : <a href=\"./Mathlib/Tactic/Push/Attr.html#Mathlib.Tactic.Push.Head\">Head</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Simproc\">Lean.Meta.Simp.Simproc</a></div></div>","info":{"doc":"Try to rewrite using a `pull` lemma. ","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pullStep","kind":"def","line":133,"name":"Mathlib.Tactic.Push.pullStep","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Push.lean#L133-L146"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pushCore\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">pushCore</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">head</span> : <a href=\"./Mathlib/Tactic/Push/Attr.html#Mathlib.Tactic.Push.Head\">Head</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">cfg</span> : <a href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.Config\">Config</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">disch?</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Meta/Tactic/Simp/Rewrite.html#Lean.Meta.Simp.Discharge\">Lean.Meta.Simp.Discharge</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">tgt</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span></div></div>","info":{"doc":"Common entry point to the implementation of `push`. ","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pushCore","kind":"def","line":122,"name":"Mathlib.Tactic.Push.pushCore","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Push.lean#L122-L131"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pushStep\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">pushStep</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">head</span> : <a href=\"./Mathlib/Tactic/Push/Attr.html#Mathlib.Tactic.Push.Head\">Head</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">cfg</span> : <a href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Simproc\">Lean.Meta.Simp.Simproc</a></div></div>","info":{"doc":"Try to rewrite using a `push` lemma. ","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pushStep","kind":"def","line":106,"name":"Mathlib.Tactic.Push.pushStep","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Push.lean#L106-L120"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pushSimpConfig\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">pushSimpConfig</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/MetaTypes.html#Lean.Meta.Simp.Config\">Lean.Meta.Simp.Config</a></div></div>","info":{"doc":"The `simp` configuration used in `push`. ","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pushSimpConfig","kind":"def","line":101,"name":"Mathlib.Tactic.Push.pushSimpConfig","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Push.lean#L101-L104"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.elabPushConfig\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">elabPushConfig</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a> → <span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.Config\">Config</a></span></span></div></div>","info":{"doc":"Function elaborating `Push.Config`. ","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.elabPushConfig","kind":"def","line":74,"name":"Mathlib.Tactic.Push.elabPushConfig","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Push.lean#L74-L75"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.Config.distrib\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">Config</span>.<span class=\"name\">distrib</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>","info":{"doc":"If `true` (default `false`), rewrite `¬ (p ∧ q)` into `¬ p ∨ ¬ q` instead of `p → ¬ q`. ","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.Config.distrib","kind":"def","line":72,"name":"Mathlib.Tactic.Push.Config.distrib","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Push.lean#L72-L72"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.Config.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">Config</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">distrib</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.Config\">Config</a></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.Config.mk","kind":"ctor","line":70,"name":"Mathlib.Tactic.Push.Config.mk","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Push.lean#L70-L70"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.Config\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">Config</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"The configuration options for the `push` tactic. ","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.Config","kind":"structure","line":69,"name":"Mathlib.Tactic.Push.Config","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Push.lean#L69-L72"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.push_neg.use_distrib\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">push_neg</span>.<span class=\"name\">use_distrib</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Data/Options.html#Lean.Option\">Lean.Option</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"Set `distrib` to true in `push_neg` and related tactics. ","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.push_neg.use_distrib","kind":"opaque","line":62,"name":"Mathlib.Tactic.Push.push_neg.use_distrib","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Push.lean#L62-L65"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.not_forall_eq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">not_forall_eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Prop</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\">(<a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\">∀ (<span class=\"fn\">x</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><span class=\"fn\">s</span> <span class=\"fn\">x</span></span></span>) <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Core.html#Exists\">∃</a> <a href=\"./Init/Core.html#Exists\">(</a><span class=\"fn\">x</span> <a href=\"./Init/Core.html#Exists\">:</a> <span class=\"fn\">α</span><a href=\"./Init/Core.html#Exists\">)</a><a href=\"./Init/Core.html#Exists\">,</a> <a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\"><span class=\"fn\">s</span> <span class=\"fn\">x</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.not_forall_eq","kind":"theorem","line":60,"name":"Mathlib.Tactic.Push.not_forall_eq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Push.lean#L60-L60"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.not_and_or_eq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">not_and_or_eq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p </span><span class=\"fn\">q</span> : <a href=\"./foundational_types.html\">Prop</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\">(<a href=\"./Init/Prelude.html#Not\">¬</a>(<span class=\"fn\">p</span> <a href=\"./Init/Prelude.html#And\">∧</a> <span class=\"fn\">q</span>)) <a href=\"./Init/Prelude.html#Eq\">=</a> (<a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\">p</span> <a href=\"./Init/Prelude.html#Or\">∨</a> <a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\">q</span>)</div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.not_and_or_eq","kind":"theorem","line":59,"name":"Mathlib.Tactic.Push.not_and_or_eq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Push.lean#L59-L59"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.not_and_eq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">not_and_eq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p </span><span class=\"fn\">q</span> : <a href=\"./foundational_types.html\">Prop</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\">(<a href=\"./Init/Prelude.html#Not\">¬</a>(<span class=\"fn\">p</span> <a href=\"./Init/Prelude.html#And\">∧</a> <span class=\"fn\">q</span>)) <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">(<span class=\"fn\">p</span> → <a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\">q</span>)</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.not_and_eq","kind":"theorem","line":58,"name":"Mathlib.Tactic.Push.not_and_eq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Push.lean#L58-L58"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.not_exists\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">not_exists</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Prop</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\"><a href=\"./Init/Core.html#Exists\">Exists</a> <span class=\"fn\">s</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">∀ (<span class=\"fn\">x</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><a href=\"./Init/BinderNameHint.html#binderNameHint\">binderNameHint</a> <span class=\"fn\">x</span> <span class=\"fn\">s</span> <a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\"><span class=\"fn\">s</span> <span class=\"fn\">x</span></span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.not_exists","kind":"theorem","line":37,"name":"Mathlib.Tactic.Push.not_exists","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Push.lean#L37-L38"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.not_iff\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">not_iff</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p </span><span class=\"fn\">q</span> : <a href=\"./foundational_types.html\">Prop</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Not\">¬</a>(<span class=\"fn\">p</span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">q</span>) <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">p</span> <a href=\"./Init/Prelude.html#And\">∧</a> <a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\">q</span> <a href=\"./Init/Prelude.html#Or\">∨</a> <a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\">p</span> <a href=\"./Init/Prelude.html#And\">∧</a> <span class=\"fn\">q</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.not_iff","kind":"theorem","line":35,"name":"Mathlib.Tactic.Push.not_iff","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Push.lean#L35-L36"}}],"imports":["Init","Lean.Elab.Tactic.Location","Mathlib.Tactic.Push.Attr","Mathlib.Logic.Basic","Mathlib.Tactic.Conv","Mathlib.Util.AtLocation"],"instances":[],"name":"Mathlib.Tactic.Push"}