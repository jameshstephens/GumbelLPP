{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.preprocess\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">preprocess</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pps</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Mathlib.Tactic.Linarith.GlobalBranchingPreprocessor\">GlobalBranchingPreprocessor</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">g</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Mathlib.Tactic.Linarith.Branch\">Branch</a>)</span></span></div></div>","info":{"doc":"`preprocess pps l` takes a list `l` of proofs of propositions.\nIt maps each preprocessor `pp ∈ pps` over this list.\nThe preprocessors are run sequentially: each receives the output of the previous one.\nNote that a preprocessor may produce multiple or no expressions from each input expression,\nso the size of the list may change.\n","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.preprocess","kind":"def","line":399,"name":"Mathlib.Tactic.Linarith.preprocess","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Preprocessing.lean#L399-L411"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.defaultPreprocessors\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">defaultPreprocessors</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Mathlib.Tactic.Linarith.GlobalBranchingPreprocessor\">GlobalBranchingPreprocessor</a></span></div></div>","info":{"doc":"The default list of preprocessors, in the order they should typically run.\n","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.defaultPreprocessors","kind":"def","line":392,"name":"Mathlib.Tactic.Linarith.defaultPreprocessors","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Preprocessing.lean#L392-L397"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.removeNe\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">removeNe</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Mathlib.Tactic.Linarith.GlobalBranchingPreprocessor\">GlobalBranchingPreprocessor</a></div></div>","info":{"doc":"`removeNe` case splits on any proof `h : a ≠ b` in the input, turning it into `a < b ∨ a > b`,\nby calling `linarith.removeNe_aux`.\nThis produces `2^n` branches when there are `n` such hypotheses in the input.\n","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.removeNe","kind":"def","line":381,"name":"Mathlib.Tactic.Linarith.removeNe","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Preprocessing.lean#L381-L388"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.removeNe_aux\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">removeNe_aux</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Mathlib.Tactic.Linarith.Branch\">Branch</a>)</span></span></span></span></div></div>","info":{"doc":"`removeNe_aux` case splits on any proof `h : a ≠ b` in the input,\nturning it into `a < b ∨ a > b`.\nThis produces `2^n` branches when there are `n` such hypotheses in the input.\n","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.removeNe_aux","kind":"opaque","line":363,"name":"Mathlib.Tactic.Linarith.removeNe_aux","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Preprocessing.lean#L363-L379"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.nlinarithExtras\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">nlinarithExtras</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Mathlib.Tactic.Linarith.GlobalPreprocessor\">GlobalPreprocessor</a></div></div>","info":{"doc":"`nlinarithExtras` is the preprocessor corresponding to the `nlinarith` tactic.\n\n* For every term `t` such that `t^2` or `t*t` appears in the input, adds a proof of `t^2 ≥ 0`\n  or `t*t ≥ 0`.\n* For every pair of comparisons `t1 R1 0` and `t2 R2 0`, adds a proof of `t1*t2 R 0`.\n\nThis preprocessor is typically run last, after all inputs have been canonized.\n","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.nlinarithExtras","kind":"def","line":344,"name":"Mathlib.Tactic.Linarith.nlinarithExtras","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Preprocessing.lean#L344-L358"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.findSquares\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">findSquares</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Std/Data/TreeSet/Basic.html#Std.TreeSet\">Std.TreeSet</a> (<a href=\"./Init/Prelude.html#Nat\">ℕ</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a>) <a href=\"./Init/Data/Ord/Basic.html#Ord.compare\">compare</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> <span class=\"fn\">(<a href=\"./Std/Data/TreeSet/Basic.html#Std.TreeSet\">Std.TreeSet</a> (<a href=\"./Init/Prelude.html#Nat\">ℕ</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a>) <a href=\"./Init/Data/Ord/Basic.html#Ord.compare\">compare</a>)</span></span></div></div>","info":{"doc":"`findSquares s e` collects all terms of the form `a ^ 2` and `a * a` that appear in `e`\nand adds them to the set `s`.\nA pair `(i, true)` is added to `s` when `atoms[i]^2` appears in `e`,\nand `(i, false)` is added to `s` when `atoms[i]*atoms[i]` appears in `e`. ","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.findSquares","kind":"opaque","line":270,"name":"Mathlib.Tactic.Linarith.findSquares","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Preprocessing.lean#L270-L298"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.cancelDenoms\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">cancelDenoms</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Mathlib.Tactic.Linarith.Preprocessor\">Preprocessor</a></div></div>","info":{"doc":"`cancelDenoms pf` assumes `pf` is a proof of `t R 0`. If `t` contains the division symbol `/`,\nit tries to scale `t` to cancel out division by numerals.\n","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.cancelDenoms","kind":"def","line":255,"name":"Mathlib.Tactic.Linarith.cancelDenoms","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Preprocessing.lean#L255-L266"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.normalizeDenominatorsLHS\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">normalizeDenominatorsLHS</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h </span><span class=\"fn\">lhs</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>","info":{"doc":"`normalizeDenominatorsLHS h lhs` assumes that `h` is a proof of `lhs R 0`.\nIt creates a proof of `lhs' R 0`, where all numeric division in `lhs` has been cancelled.\n","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.normalizeDenominatorsLHS","kind":"def","line":237,"name":"Mathlib.Tactic.Linarith.normalizeDenominatorsLHS","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Preprocessing.lean#L237-L253"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.without_one_mul\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">without_one_mul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#MulOneClass\">MulOneClass</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">M</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">1</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.without_one_mul","kind":"theorem","line":234,"name":"Mathlib.Tactic.Linarith.without_one_mul","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Preprocessing.lean#L234-L235"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.compWithZero\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">compWithZero</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Mathlib.Tactic.Linarith.Preprocessor\">Preprocessor</a></div></div>","info":{"doc":"`compWithZero h` takes a proof `h` of an equality, inequality, or negation thereof,\nand turns it into a proof of a comparison `_ R 0`, where `R ∈ {=, ≤, <}`.\n","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.compWithZero","kind":"def","line":222,"name":"Mathlib.Tactic.Linarith.compWithZero","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Preprocessing.lean#L222-L228"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.rearrangeComparison\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">rearrangeComparison</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>","info":{"doc":"`rearrangeComparison e` takes a proof `e` of an equality, inequality, or negation thereof,\nand turns it into a proof of a comparison `_ R 0`, where `R ∈ {=, ≤, <}`.\n","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.rearrangeComparison","kind":"def","line":212,"name":"Mathlib.Tactic.Linarith.rearrangeComparison","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Preprocessing.lean#L212-L220"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.strengthenStrictInt\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">strengthenStrictInt</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Mathlib.Tactic.Linarith.Preprocessor\">Preprocessor</a></div></div>","info":{"doc":"`strengthenStrictInt h` turns a proof `h` of a strict integer inequality `t1 < t2`\ninto a proof of `t1 ≤ t2 + 1`. ","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.strengthenStrictInt","kind":"def","line":202,"name":"Mathlib.Tactic.Linarith.strengthenStrictInt","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Preprocessing.lean#L202-L206"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.mkNonstrictIntProof\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">mkNonstrictIntProof</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pf</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>","info":{"doc":"If `pf` is a proof of a strict inequality `(a : ℤ) < b`,\n`mkNonstrictIntProof pf` returns a proof of `a + 1 ≤ b`,\nand similarly if `pf` proves a negated weak inequality.\n","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.mkNonstrictIntProof","kind":"def","line":188,"name":"Mathlib.Tactic.Linarith.mkNonstrictIntProof","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Preprocessing.lean#L188-L200"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.natToInt\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">natToInt</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Mathlib.Tactic.Linarith.GlobalBranchingPreprocessor\">GlobalBranchingPreprocessor</a></div></div>","info":{"doc":"If `h` is an equality or inequality between natural numbers,\n`natToInt` lifts this inequality to the integers.\nIt also adds the facts that the integers involved are nonnegative.\nTo avoid adding the same nonnegativity facts many times, it is a global preprocessor.\n","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.natToInt","kind":"def","line":145,"name":"Mathlib.Tactic.Linarith.natToInt","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Preprocessing.lean#L145-L182"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.Expr.Ord\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">Expr</span>.<span class=\"name\">Ord</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Ord/Basic.html#Ord\">_root_.Ord</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>","info":{"doc":"Ordering on `Expr`. ","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.Expr.Ord","kind":"def","line":137,"name":"Mathlib.Tactic.Linarith.Expr.Ord","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Preprocessing.lean#L137-L143"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.mk_natCast_nonneg_prf\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">mk_natCast_nonneg_prf</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>","info":{"doc":"If `e : ℕ`, returns a proof of `0 ≤ (e : C)`. ","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.mk_natCast_nonneg_prf","kind":"def","line":129,"name":"Mathlib.Tactic.Linarith.mk_natCast_nonneg_prf","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Preprocessing.lean#L129-L135"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.getNatComparisons\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">getNatComparisons</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></div></div>","info":{"doc":"`getNatComparisons e` returns a list of all subexpressions of `e` of the form `((t : ℕ) : C)`.\n","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.getNatComparisons","kind":"opaque","line":116,"name":"Mathlib.Tactic.Linarith.getNatComparisons","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Preprocessing.lean#L116-L127"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.isNatCoe\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">isNatCoe</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></div></div>","info":{"doc":"If `e` is of the form `((n : ℕ) : C)`, `isNatCoe e` returns `⟨n, C⟩`. ","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.isNatCoe","kind":"def","line":110,"name":"Mathlib.Tactic.Linarith.isNatCoe","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Preprocessing.lean#L110-L114"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.isNatProp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">isNatProp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"`isNatProp tp` is true iff `tp` is an inequality or equality between natural numbers\nor the negation thereof.\n","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.isNatProp","kind":"def","line":103,"name":"Mathlib.Tactic.Linarith.isNatProp","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Preprocessing.lean#L103-L108"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.removeNegations\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">removeNegations</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Mathlib.Tactic.Linarith.Preprocessor\">Preprocessor</a></div></div>","info":{"doc":"Replaces proofs of negations of comparisons with proofs of the reversed comparisons.\nFor example, a proof of `¬ a < b` will become a proof of `a ≥ b`.\n","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.removeNegations","kind":"def","line":80,"name":"Mathlib.Tactic.Linarith.removeNegations","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Preprocessing.lean#L80-L95"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.flipNegatedComparison\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">flipNegatedComparison</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">prf </span><span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>","info":{"doc":"If `prf` is a proof of `¬ e`, where `e` is a comparison,\n`flipNegatedComparison prf e` flips the comparison in `e` and returns a proof.\nFor example, if `prf : ¬ a < b`, ``flipNegatedComparison prf q(a < b)`` returns a proof of `a ≥ b`.\n","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.flipNegatedComparison","kind":"def","line":69,"name":"Mathlib.Tactic.Linarith.flipNegatedComparison","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Preprocessing.lean#L69-L78"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.filterComparisons\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">filterComparisons</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Mathlib.Tactic.Linarith.Preprocessor\">Preprocessor</a></div></div>","info":{"doc":"Removes any expressions that are not proofs of inequalities, equalities, or negations thereof.\n","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.filterComparisons","kind":"def","line":55,"name":"Mathlib.Tactic.Linarith.filterComparisons","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Preprocessing.lean#L55-L65"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.splitConjunctions\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">splitConjunctions</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Mathlib.Tactic.Linarith.Preprocessor\">Preprocessor</a></div></div>","info":{"doc":"Processor that recursively replaces `P ∧ Q` hypotheses with the pair `P` and `Q`. ","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.splitConjunctions","kind":"def","line":42,"name":"Mathlib.Tactic.Linarith.splitConjunctions","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Preprocessing.lean#L42-L53"}}],"imports":["Init","Mathlib.Control.Basic","Mathlib.Lean.Meta.Tactic.Rewrite","Mathlib.Tactic.CancelDenoms.Core","Mathlib.Tactic.Linarith.Datatypes","Mathlib.Tactic.Zify","Mathlib.Util.AtomM"],"instances":[],"name":"Mathlib.Tactic.Linarith.Preprocessing"}